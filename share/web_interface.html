<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>VRPipe</title>
        
        <!-- jQuery for REST interaction, and needed by bootstrap.js -->
        <script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
        
        <!-- Bootstrap for presentation and styling -->
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css">
        <script src="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>
        <!--[if lt IE 9]>
          <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
          <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->
        
        <!-- Knockout for event handling -->
        <script src="http://cdnjs.cloudflare.com/ajax/libs/knockout/3.1.0/knockout-min.js"></script>
        
        <!-- Knockstrap to make buttons and things work 2-way between knockout and bootstrap -->
        <script src="/js/knockstrap.min.js"></script>
        
        <!-- Simrou for client-side navigation -->
        <script src="/js/simrou.min.js"></script>
        
        <!-- Cytoscape for graph display -->
        <script src="/js/cytoscape.min.js"></script>
        
        <style>
            .loader {
                background-image: url(data:image/gif;base64,R0lGODlhEAALAPQAAP///0pISOTk5N3d3e/v705MTEpISGpoaKalpY6MjM3NzWJgYH59fauqqpCPj9DQ0GRjY0xKSoF/f+zs7OPi4vb29nFwcOXl5fX19crKyru6utnY2PLy8gAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/hpDcmVhdGVkIHdpdGggYWpheGxvYWQuaW5mbwAh+QQJCwAAACwAAAAAEAALAAAFLSAgjmRpnqSgCuLKAq5AEIM4zDVw03ve27ifDgfkEYe04kDIDC5zrtYKRa2WQgAh+QQJCwAAACwAAAAAEAALAAAFJGBhGAVgnqhpHIeRvsDawqns0qeN5+y967tYLyicBYE7EYkYAgAh+QQJCwAAACwAAAAAEAALAAAFNiAgjothLOOIJAkiGgxjpGKiKMkbz7SN6zIawJcDwIK9W/HISxGBzdHTuBNOmcJVCyoUlk7CEAAh+QQJCwAAACwAAAAAEAALAAAFNSAgjqQIRRFUAo3jNGIkSdHqPI8Tz3V55zuaDacDyIQ+YrBH+hWPzJFzOQQaeavWi7oqnVIhACH5BAkLAAAALAAAAAAQAAsAAAUyICCOZGme1rJY5kRRk7hI0mJSVUXJtF3iOl7tltsBZsNfUegjAY3I5sgFY55KqdX1GgIAIfkECQsAAAAsAAAAABAACwAABTcgII5kaZ4kcV2EqLJipmnZhWGXaOOitm2aXQ4g7P2Ct2ER4AMul00kj5g0Al8tADY2y6C+4FIIACH5BAkLAAAALAAAAAAQAAsAAAUvICCOZGme5ERRk6iy7qpyHCVStA3gNa/7txxwlwv2isSacYUc+l4tADQGQ1mvpBAAIfkECQsAAAAsAAAAABAACwAABS8gII5kaZ7kRFGTqLLuqnIcJVK0DeA1r/u3HHCXC/aKxJpxhRz6Xi0ANAZDWa+kEAA7AAAAAAAAAAAA);
                height: 11px;
                width: 16px;
            }
        </style>
    </head>
    <body>
        <div id="nav" class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <span class="navbar-brand">VRPipe</span>
                    <ul class="nav navbar-nav nav-tabs" id="tabsections">
                        <li class="active"><a href="#home" data-toggle="tab">Home</a></li>
                        <li><a href="#status" data-toggle="tab">Status</a></li>
                        <li><a href="#graph" data-toggle="tab">Graph</a></li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="container">
            <div class="tab-content">
                <div id="home" class="tab-pane fade in active">
                    <div class="jumbotron">
                        <h1>Welcome, friend!</h1>
                        <p>You've successfully connected to your VRPipe server. This web interface will have many more features coming soon; the first two - checking status of your pipeline setups and looking at the graph database - can be accessed using the links in the navigation bar above.</p>
                    </div>
                </div>
                
                <div id="status" class="tab-pane fade">
                    <h3>Status</h3>
                </div>
                
                <div id="graph" class="tab-pane fade">
                    <div id ="top">
                        <h3>Graph</h3>
                        
                        <form data-bind="submit: runCypherQuery">
                            <div class="row">
                                <div class="col-xs-10">
                                    <div class="input-group">
                                        <span class="input-group-addon" data-toggle="tooltip" data-container="body" title="Enter a cypher query that returns nodes and relationships. Be careful to limit your query if necessary.">cypher $</span>
                                        <input type="text" class="form-control" data-bind="value: cypherQuery">
                                        <span class="input-group-btn">
                                            <button class="btn btn-default" type="submit"><span class="glyphicon glyphicon-play-circle"></span></button>
                                        </span>
                                    </div>
                                </div>
                                <div class="col-xs-2">
                                    <div class="input-group">
                                        <span class="input-group-addon" data-toggle="tooltip" data-container="body" title="When clicking on a node to see its children, this is the maxium depth to search for those children.">max depth</span>
                                        <input type="text" class="form-control" data-bind="value: relationsOfMaxDepth">
                                    </div>
                                </div>
                            </div>
                        </form>
                        
                        <div class="btn-toolbar" role="toolbar" style="margin-top: 15px; margin-bottom: 20px">
                            <div class="btn-group" data-toggle="buttons" data-bind="radio: startNodesOption">
                                <label class="btn btn-primary">
                                    <input type="radio" name="startNodesOptionGroup" value="roots">Roots
                                </label>
                            </div>
                            
                            <div class="btn-group" data-toggle="buttons" data-bind="radio: layoutOption">
                                <label class="btn btn-default disabled">Layout:</label> 
                                <label class="btn btn-default">
                                    <input type="radio" name="layoutOptionGroup" value="tree">Tree
                                </label>
                                <label class="btn btn-default">
                                    <input type="radio" name="layoutOptionGroup" value="circle">Circle
                                </label>
                                <label class="btn btn-default">
                                    <input type="radio" name="layoutOptionGroup" value="grid">Grid
                                </label>
                                <label class="btn btn-default">
                                    <input type="radio" name="layoutOptionGroup" value="force">Force
                                </label>
                            </div>
                            
                            <div class="btn-group" data-bind="foreach: nameSpaces">
                                <div class="btn-group">
                                    <button type="button" class="btn btn-default dropdown-toggle" data-toggle="dropdown" data-bind="style: { backgroundColor: hsl }">
                                        <span data-bind="text: namespace"></span>
                                        <span class="caret"></span>
                                    </button>
                                    <ul class="dropdown-menu" role="menu" data-bind="foreach: labels">
                                        <li><div class="text-center" style="padding: 5px" data-bind="text: label, style: { backgroundColor: hsl }"></div></li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                        
                        <div id="grapherrors" data-bind="foreach: grapherror">
                            <div class="alert alert-danger fade in">
                                <p data-bind="text: $data"></p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="well">
                        <div id="nodeinfo" style="position: absolute;" data-container="body" data-toggle="popover" data-placement="right" data-html="true" data-trigger="manual"></div>
                        
                        <div id="cy" data-bind="loadingWhen: graphloading().length"></div>
                    </div>
                    
                    <div data-bind="loadingWhen: graphloading().length, if: resultStrings().length">
                        <div class="panel panel-default">
                            <div class="panel-heading">Values</div>
                            <div class="table-responsive">
                                <table class="table table-striped">
                                    <tbody data-bind="foreach: resultStrings">
                                        <tr>
                                            <td data-bind="text: $data"></td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                    
                    <div data-bind="loadingWhen: graphloading().length, if: nodes().length">
                        <div class="panel panel-default">
                            <div class="panel-heading">Nodes</div>
                            <div class="table-responsive">
                                <table class="table table-striped">
                                    <thead>
                                        <tr>
                                            <th>Namespace</th>
                                            <th>Label</th>
                                            <th>Properties</th>
                                            <th>Node ID</th>
                                        </tr>
                                    <thead>
                                    <tbody data-bind="foreach: nodes">
                                        <tr>
                                            <td data-bind="text: namespace"></td>
                                            <td data-bind="text: label"></td>
                                            <td data-bind="text: properties"></td>
                                            <td data-bind="text: nodeId"></td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                    
                    <div data-bind="loadingWhen: graphloading().length, if: relationships().length">
                        <div class="panel panel-default">
                            <div class="panel-heading">Relationships</div>
                            <div class="table-responsive">
                                <table class="table table-striped">
                                    <thead>
                                        <tr>
                                            <th>Type</th>
                                            <th>Start Node</th>
                                            <th>End Node</th>
                                            <th>Properties</th>
                                            <th>Relationship ID</th>
                                        </tr>
                                    <thead>
                                    <tbody data-bind="foreach: relationships">
                                        <tr>
                                            <td data-bind="text: type"></td>
                                            <td data-bind="text: startNode"></td>
                                            <td data-bind="text: endNode"></td>
                                            <td data-bind="text: properties"></td>
                                            <td data-bind="text: relationshipId"></td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <hr>
            
            <footer id="footer">
                <small>&copy; 2014 Genome Research Limited.</small>
            </footer>
        </div>
        
        <script type="text/javascript">
            // turn on bootstrap tooltips and popovers
            $('[data-toggle="tooltip"]').tooltip({'placement': 'top'});
            $('[data-toggle="popover"]').popover();
            
            // client-side routes for the main sections, which basically just
            // ensure that the correct tab is shown if user changes url in
            // browser
            var router = new Simrou();
            var route = router.addRoute('/home');
            route.get(function(event, params) {
                $('#tabsections a[href="#home"]').tab('show');
            });
            route = router.addRoute('/status');
            route.get(function(event, params) {
                $('#tabsections a[href="#status"]').tab('show');
            });
            route = router.addRoute('/graph');
            route.get(function(event, params) {
                $('#tabsections a[href="#graph"]').tab('show');
            });
            
            // we have a custom ko binding to handle our loading feedback
            // (from http://blog.greatrexpectations.com/2012/06/17/loading-placeholders-using-knockout-js/)
            ko.bindingHandlers.loadingWhen = {
                init: function (element) {
                    var $element = $(element),
                        currentPosition = $element.css("position")
                        $loader = $("<div>").addClass("loader").hide();
                    
                    //add the loader
                    $element.append($loader);
                    
                    //make sure that we can absolutely position the loader against the original element
                    if (currentPosition == "auto" || currentPosition == "static")
                        $element.css("position", "relative");

                    //center the loader
                    $loader.css({
                        position: "absolute",
                        top: "20px",
                        left: "50%",
                        "margin-left": -($loader.width() / 2) + "px"
                    });
                },
                update: function (element, valueAccessor) {
                    var isLoading = ko.utils.unwrapObservable(valueAccessor()),
                        $element = $(element),
                        $childrenToHide = $element.children(":not(div.loader)"),
                        $loader = $element.find("div.loader");

                    if (isLoading) {
                        $childrenToHide.css("visibility", "hidden").attr("disabled", "disabled");
                        $loader.fadeIn("slow");
                    }
                    else {
                        $loader.fadeOut("fast");
                        $childrenToHide.css("visibility", "visible").removeAttr("disabled");
                    }
                }
            };
            
            // ajax function to send/get json queries
            var ajax = function(uri, method, loading, error, data) {
                var loadingTimeout;
                var request = {
                    url: uri,
                    type: method,
                    contentType: "application/json",
                    accepts: "application/json",
                    cache: false,
                    dataType: 'json',
                    data: JSON.stringify(data),
                    beforeSend: function (xhr) {
                        // say that we're loading, but only if for more than
                        // half a second
                        if (loadingTimeout) { clearTimeout(loadingTimeout); }
                        loadingTimeout = setTimeout(function() {
                            loading.push(true);
                        }, 500);
                    },
                    error: function(jqXHR, textStatus, errorThrown) {
                        if (textStatus) {
                            var msg = "Ajax " + textStatus + " " + jqXHR.status + " connecting to " + uri;
                            if (errorThrown) {
                                msg = msg + ": " + errorThrown;
                            }
                            error.push(msg);
                        }
                    },
                    complete: function(jqXHR, textStatus) {
                        if (loadingTimeout) { clearTimeout(loadingTimeout); }
                        loading.pop();
                    }
                };
                return $.ajax(request);
            }
            
            // function to call a VRPipe Graph method and do something with the
            // json response, and its helper function to deal with errors
            var vrpipeGraphDataErrorParser = function(data, error) {
                if (data.hasOwnProperty('errors')) {
                    for (var i = 0; i < data.errors.length; i++) {
                        error.push(data.errors[i]);
                    }
                    return 1;
                }
                return 0;
            }
            var vrpipeGraphMethod = function(method, args, loading, error, donefunction) {
                var promise = ajax('/rest/graph/' + method, 'POST', loading, error, args);
                
                if (donefunction) {
                    promise.done(function(data) {
                        if (! vrpipeGraphDataErrorParser(data, error)) {
                            donefunction(data);
                        }
                    });
                }
                else {
                    return promise;
                }
            }
            
            // viewmodel for status
            function StatusViewModel() {
                var self = this;
                
                // pipelinesetup status stuff
            }
            
            // viewmodel for graph
            function GraphViewModel() {
                var self = this;
                self.nodes = ko.observableArray();
                self.relationships = ko.observableArray();
                self.resultStrings = ko.observableArray();
                self.startNodesOption = ko.observable();
                self.relationsOf = undefined;
                self.relationsOfMaxDepth = ko.observable();
                self.cypherQuery = ko.observable();
                self.layoutOption = ko.observable();
                self.nextHue = 0;
                self.namespaceToHSL = {};
                self.labelToHSL = {};
                self.nameSpaces = ko.observableArray();
                self.deploymentLabel = '%%deploymentLabel%%';
                self.schemas = {};
                self.graphloading = ko.observableArray();
                self.grapherror = ko.observableArray();
                
                // while cytoscape has the ability to add and remove nodes from a
                // graph, I can't figure out how to re-apply the breadthfirst, so
                // for now we'll just store the cytoscape options here and recreate
                // new cytoscape object for every graph update
                self.cytoscapeOptions = {
                    container: $('#cy')[0],
                    
                    userZoomingEnabled: 0,
                    
                    style: [
                        {
                            selector: 'node',
                            css: {
                                'content': 'data(displayName)',
                                'font-family': 'helvetica',
                                'font-size': 12,
                                'text-valign': 'center',
                                'color': '#000',
                                'border-color': 'data(lineColor)',
                                'border-width': 2,
                                'background-color': 'data(bgColor)'
                            }
                        },
                        
                        {
                            selector: ':selected',
                            css: {
                                'background-color': '#000',
                                'line-color': '#000',
                                'target-arrow-color': '#000',
                                'text-outline-color': '#000'
                            }
                        },
                        
                        {
                            selector: 'edge',
                            css: {
                                'width': 2,
                                'target-arrow-shape': 'triangle',
                                'content': 'data(type)',
                                'font-size': 8
                            }
                        }
                    ]
                };
                
                // we'll display our cytoscape graph on the #cy div, making it
                // fill the remaining vertical space
                $(document).ready(function() {
                    var $nav = $('#nav');
                    var $top = $('#top'); // on initial page load with the graph tab hidden, this is 0 instead of ~135
                    var $cy = $('#cy');
                    $(window).on('resize', function(){
                       var height = $(this).height() - $nav.outerHeight() - 135 - 100;
                       $cy.height(height);
                       self.plotCytoscape();
                    }).trigger('resize');
                });
                
                // we want different labels to get different colors, so here's
                // a function to get the next most different hsl (from
                // http://ridiculousfish.com/blog/posts/colors.html)
                self.getHSL = function() {
                    var idx = self.nextHue++;
                    var bitcount = 31;
                    var ridx = 0, i = 0;
                    for (i=0; i < bitcount; i++) {
                        ridx = (ridx << 1) | (idx & 1);
                        idx >>>= 1;
                    }
                    var hue = ridx / Math.pow(2, bitcount);
                    hue = (hue + .1) % 1;
                    var degrees = Math.round(hue * 360);
                    return 'hsl(' + degrees + ', 75%, 75%)';
                }
                
                // functions to create cytoscape nodes and plot them
                self.plotCytoscape = function() {
                    if (! self.layoutOption()) {
                        self.layoutOption('tree');
                    }
                    if (self.layoutOption() == 'tree') {
                        self.cytoscapeOptions.layout = {
                            name: 'breadthfirst',
                            fit: true,
                            ready: undefined,
                            stop: undefined,
                            directed: true,
                            padding: 30,
                            circle: false,
                            roots: undefined,
                            maximalAdjustments: 0
                        };
                    }
                    else if (self.layoutOption() == 'circle') {
                        self.cytoscapeOptions.layout = {
                            name: 'circle',
                            fit: true,
                            ready: undefined,
                            stop: undefined,
                            rStepSize: 10,
                            padding: 30,
                            startAngle: 3/2 * Math.PI,
                            counterclockwise: false
                        };
                    }
                    else if (self.layoutOption() == 'grid') {
                        self.cytoscapeOptions.layout = {
                            name: 'grid',
                            fit: true,
                            padding: 30,
                            rows: undefined,
                            columns: undefined,
                            position: function( node ){},
                            ready: undefined,
                            stop: undefined
                        };
                    }
                    else if (self.layoutOption() == 'force') {
                        self.cytoscapeOptions.layout = {
                            name: 'cose',
                            fit: true, 
                            ready: undefined,
                            stop: undefined,
                            refresh: 0,
                            padding: 30,
                            randomize: true,
                            debug: false,
                            nodeRepulsion: 10000,
                            nodeOverlap: 10000,
                            idealEdgeLength: 50,
                            edgeElasticity: 1000,
                            nestingFactor: 1,
                            gravity: 1,
                            numIter: 10000,
                            initialTemp: 10000,
                            coolingFactor: 0.95,
                            minTemp: 1
                        };
                    }
                    
                    self.cytoscapeOptions.ready = function(){
                        cy = this;
                        cy.fit();
                        
                        // clicking on a node should show its related nodes
                        cy.$('node').one('tap', function(e){
                            location.hash = '/graph/related/' + e.cyTarget.id() + '/depth/' + self.relationsOfMaxDepth();
                        });
                        
                        // change node color on mouseover; I don't know how
                        // or if this can be done in the main style option
                        // like :selected is defined. Cytoscape doesn't
                        // support changing the cursor anyway. And we also
                        // show a popover with the node details
                        var hideTimer;
                        cy.$('node').on('tapdragover', function(e) {
                            if (hideTimer) { clearTimeout(hideTimer); }
                            
                            var node = e.cyTarget;
                            $('#nodeinfo').data('bs.popover').options.title = '<div class="text-center">' + node.data('namespace') + '|' + node.data('label') + ' {node ' + node.id() + '}</div>';
                            var nodeProperties = '<table class="table table-bordered table-striped table-condensed" style="margin-bottom: 0"><tbody>';
                            $.each(node.data('properties'), function(key, value) {
                                nodeProperties = nodeProperties + '<tr><th>' + key + '</th><td>' + value + '</td></tr>';
                            });
                            nodeProperties = nodeProperties + '</tbody></table>';
                            $('#nodeinfo').data('bs.popover').options.content = nodeProperties;
                            
                            node.css('background-color', '#888');
                            $('#cy').css('cursor', 'pointer');
                            $(document).mousemove(function(event) {
                                $("#nodeinfo").css({left: event.pageX + 40, top: event.pageY});
                                $('#nodeinfo').popover('show');
                                $(document).off('mousemove');
                            });
                        });
                        cy.$('node').on('tapdragout tap', function(e) {
                            var node = e.cyTarget;
                            node.css('background-color', node.data('bgColor'));
                            $('#cy').css('cursor', 'default');
                            hideTimer = setTimeout(function() {
                                $('#nodeinfo').popover('hide');
                            }, 333);
                        });
                    }
                    
                    return cytoscape(self.cytoscapeOptions);
                }
                
                self.createCytoscapeNodesAndPlot = function(nodeData, labelData, rootNodes) {
                    for (var i = 0; i < nodeData.length; i++) {
                        var node = nodeData[i];
                        var uniqueParam = self.schemas[node.schemaLabels];
                        var displayName = node.label;
                        if (uniqueParam && node.properties[uniqueParam]) {
                            displayName = node.properties[uniqueParam];
                        }
                        
                        self.cytoscapeOptions.elements.nodes.push({ data: { id: node.nodeId, displayName: displayName, label: node.label, namespace: node.namespace, properties: node.properties, bgColor: node.labelHSL, lineColor: node.nameSpaceHSL } });
                    }
                    
                    var cy = self.plotCytoscape();
                    
                    $.each(labelData, function(namespace, nsObj) {
                        var result = { namespace: namespace, hsl: nsObj.hsl, labels: Array() };
                        
                        // get the correct order of labels to make
                        // the colour key
                        var labelCount = 0;
                        for (x in nsObj.labels) {
                            labelCount++;
                        }
                        var currentCount = 0;
                        var labelOrder = {};
                        var orderLabel = Array();
                        var order = 1;
                        var roots = rootNodes[namespace];
                        for (var i = 0; i < roots.length; i++) {
                            var done = cy.elements().dfs('#' + roots[i], function(i, depth) {
                                var thisLabel = this.data('label');
                                if (! labelOrder.hasOwnProperty(thisLabel)) {
                                    labelOrder[thisLabel] = order++;
                                    orderLabel.push(thisLabel);
                                    
                                    currentCount++;
                                    if (currentCount == labelCount) {
                                        return true;
                                    }
                                }
                            }, true);
                            if (done) { break; }
                        }
                        
                        for (i in orderLabel) {
                            var label = orderLabel[i];
                            result.labels.push({ label: label, hsl: nsObj.labels[label] });
                        }
                        self.nameSpaces.push(result);
                    });
                }
                
                // reset all existing stuff and call vrpipeGraphMethod to get
                // desired nodes from the database
                self.getNodes = function(method, args) {
                    self.grapherror.removeAll();
                    self.nodes.removeAll();
                    self.relationships.removeAll();
                    self.resultStrings.removeAll();
                    self.nameSpaces.removeAll();
                    self.cytoscapeOptions.elements = {
                        nodes: [ ],
                        edges: [ ]
                    };
                    self.plotCytoscape(); // plot the empty graph to clear it
                    
                    vrpipeGraphMethod(method, args, self.graphloading, self.grapherror, function(data) {
                        // turn data in to nodes and relationships for display
                        // in knockout tables and cytoscape graph
                        
                        // relationships
                        var nonRootNodes = { };
                        if (data.hasOwnProperty('relationships')) {
                            for (var i = 0; i < data.relationships.length; i++) {
                                var reldata = data.relationships[i];
                                var start = reldata.startNode;
                                var end = reldata.endNode;
                                var type = reldata.type;
                                self.relationships.push({
                                    type: type,
                                    startNode: start,
                                    endNode: end,
                                    properties: JSON.stringify(reldata.properties),
                                    relationshipId: reldata.id
                                });
                                
                                self.cytoscapeOptions.elements.edges.push({ data: { source: start, target: end, type: type } });
                                nonRootNodes[end] = 1;
                            }
                        }
                        
                        // nodes
                        if (data.hasOwnProperty('nodes')) {
                            var schemaRequests = Array();
                            var schemaLabelsArray = Array();
                            var rootNodes = {};
                            var tempLabelData = {};
                            var tempNodes = Array();
                            for (var i = 0; i < data.nodes.length; i++) {
                                var nodedata = data.nodes[i];
                                var label = nodedata.label;
                                var namespace = nodedata.namespace;
                                
                                // for the tabular display of node data
                                self.nodes.push({
                                    label: label,
                                    namespace: namespace,
                                    properties: JSON.stringify(nodedata.properties),
                                    nodeId: nodedata.id
                                });
                                
                                // get a unique colour for each namespace and label
                                var nameSpaceHSL;
                                if (! self.namespaceToHSL.hasOwnProperty(namespace)) {
                                    nameSpaceHSL = self.getHSL();
                                    self.namespaceToHSL[namespace] = nameSpaceHSL;
                                }
                                else {
                                    nameSpaceHSL = self.namespaceToHSL[namespace];
                                }
                                if (! tempLabelData.hasOwnProperty(namespace)) {
                                    tempLabelData[namespace] = { hsl: nameSpaceHSL, labels: {} };
                                }
                                
                                var labelHSL;
                                if (! self.labelToHSL.hasOwnProperty(label)) {
                                    labelHSL = self.getHSL();
                                    self.labelToHSL[label] = labelHSL;
                                }
                                else {
                                    labelHSL = self.labelToHSL[label];
                                }
                                if (! tempLabelData[namespace].labels.hasOwnProperty(label)) {
                                    tempLabelData[namespace].labels[label] = labelHSL;
                                }
                                
                                // we need to know the first unique parameter for
                                // this kind of node so we know what to display on
                                // the cytoscape node
                                var nl = namespace + '|' + label;
                                if (! self.schemas.hasOwnProperty(nl)) {
                                    schemaRequests.push(vrpipeGraphMethod('get_schema', { namespace: namespace, label: label }, self.graphloading, self.grapherror));
                                    schemaLabelsArray.push(nl);
                                    self.schemas[nl] = 'placeholder';
                                }
                                
                                // push out the info we need later to make the
                                // cytoscape nodes, once we have the schema
                                tempNodes.push({
                                    label: label,
                                    namespace: namespace,
                                    properties: nodedata.properties,
                                    nodeId: nodedata.id,
                                    schemaLabels: nl,
                                    nameSpaceHSL: nameSpaceHSL,
                                    labelHSL: labelHSL,
                                });
                                
                                // we need to know which nodes are root nodes and
                                // group them by namespace
                                if (! nonRootNodes.hasOwnProperty(nodedata.id)) {
                                    if (! rootNodes.hasOwnProperty(namespace)) {
                                        rootNodes[namespace] = Array();
                                    }
                                    rootNodes[namespace].push(nodedata.id);
                                }
                            }
                            
                            // create nodes and plot
                            if (schemaRequests.length) {
                                // add to our hash of schemaLabel => unique parameter name
                                var defer = $.when.apply($, schemaRequests);
                                defer.done(function() {
                                    $.each(arguments, function(index, data) {
                                        var schemadata;
                                        if (schemaRequests.length == 1) {
                                            schemadata = data;
                                        }
                                        else {
                                            schemadata = data[0];
                                        }
                                        
                                        if (index < schemaRequests.length) {
                                            if (! vrpipeGraphDataErrorParser(schemadata, self.grapherror)) {
                                                self.schemas[schemaLabelsArray[index]] = schemadata.uniques[0];
                                            }
                                        }
                                    });
                                    self.createCytoscapeNodesAndPlot(tempNodes, tempLabelData, rootNodes);
                                });
                            }
                            else {
                                self.createCytoscapeNodesAndPlot(tempNodes, tempLabelData, rootNodes);
                            }
                        }
                    });
                }
                
                // operations
                self.runCypherQuery = function() {
                    if (self.cypherQuery()) {
                        self.startNodesOption(undefined);
                        location.hash = '/graph/cypher/' + self.cypherQuery();
                    }
                }
                
                // trigger route when choice of start node type changes
                self.startNodesOption.subscribe(function(newValue) {
                    if (newValue) {
                        location.hash = '/graph/start/' + newValue;
                    }
                });
                
                // update graph when choice of layout changes
                self.layoutOption.subscribe(function(newValue) {
                    if (newValue) {
                        self.plotCytoscape();
                    }
                });
                
                // when choice of relations depth changes, redraw graph
                self.relationsOfMaxDepth.subscribe(function(newValue) {
                    if (newValue && self.relationsOf) {
                        location.hash = '/graph/related/' + self.relationsOf + '/depth/' + newValue;
                    }
                });
                if (! self.relationsOfMaxDepth()) {
                    self.relationsOfMaxDepth(2);
                }
                
                // client-side routes
                route = router.addRoute('/graph/start/:startNodesOption');
                route.get(function(event, params) {
                    $('#tabsections a[href="#graph"]').tab('show');
                    self.cypherQuery(undefined);
                    self.relationsOf = undefined;
                    self.startNodesOption(params.startNodesOption); // to update ui if url changed manually in browser
                    if (params.startNodesOption == "roots") {
                        self.layoutOption('grid');
                        self.getNodes('root_nodes', { });
                    }
                });
                route = router.addRoute('/graph/related/:nodeID/depth/:maxDepth');
                route.get(function(event, params) {
                    $('#tabsections a[href="#graph"]').tab('show');
                    self.startNodesOption(undefined);
                    self.cypherQuery(undefined);
                    self.relationsOf = undefined;
                    self.relationsOfMaxDepth(params.maxDepth);
                    self.relationsOf = params.nodeID;
                    self.layoutOption('tree');
                    self.getNodes('relations_of', { start_node: self.relationsOf, depth: self.relationsOfMaxDepth() });
                });
                route = router.addRoute('/graph/cypher/:cypherQuery');
                route.get(function(event, params) {
                    $('#tabsections a[href="#graph"]').tab('show');
                    self.startNodesOption(undefined);
                    self.relationsOf = undefined;
                    self.cypherQuery(decodeURIComponent(params.cypherQuery));
                    self.getNodes('cypher_match', { cypher: self.cypherQuery() });
                });
            }
            var gvm = new GraphViewModel();
            ko.applyBindings(gvm, $('#graph')[0]);
            
            router.start('/home');
            
            // sync up url when we change section tabs using the UI
            $('a[data-toggle="tab"]').on('show.bs.tab', function(e) {
                var activeTab = $(e.target).text(); // Get the name of active tab
                if (activeTab == "Home") {
                    location.hash = '/home';
                }
                else if (activeTab == "Status") {
                    location.hash = '/status';
                }
                else if (activeTab == "Graph") {
                    location.hash = '/graph' + (gvm.startNodesOption() ? ('/start=' + gvm.startNodesOption()) : '');
                }
            });
        </script>
    </body>
</html>
