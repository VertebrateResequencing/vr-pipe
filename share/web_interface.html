<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>VRPipe</title>
        
        <!-- jQuery for REST interaction, and needed by bootstrap.js -->
        <script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
        
        <!-- Bootstrap for presentation and styling -->
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css">
        <script src="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>
        <!--[if lt IE 9]>
          <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
          <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->
        
        <!-- Knockout for event handling -->
        <script src="http://cdnjs.cloudflare.com/ajax/libs/knockout/3.1.0/knockout-min.js"></script>
        
        <!-- Knockstrap to make buttons and things work 2-way between knockout and bootstrap -->
        <script src="js/knockstrap.min.js"></script>
        
        <!-- Simrou for client-side navigation -->
        <script src="js/simrou.min.js"></script>
        
        <!-- Cytoscape for graph display -->
        <script src="js/cytoscape.min.js"></script>
        
        <style>
            .loader {
                background-image: url(data:image/gif;base64,R0lGODlhEAALAPQAAP///0pISOTk5N3d3e/v705MTEpISGpoaKalpY6MjM3NzWJgYH59fauqqpCPj9DQ0GRjY0xKSoF/f+zs7OPi4vb29nFwcOXl5fX19crKyru6utnY2PLy8gAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/hpDcmVhdGVkIHdpdGggYWpheGxvYWQuaW5mbwAh+QQJCwAAACwAAAAAEAALAAAFLSAgjmRpnqSgCuLKAq5AEIM4zDVw03ve27ifDgfkEYe04kDIDC5zrtYKRa2WQgAh+QQJCwAAACwAAAAAEAALAAAFJGBhGAVgnqhpHIeRvsDawqns0qeN5+y967tYLyicBYE7EYkYAgAh+QQJCwAAACwAAAAAEAALAAAFNiAgjothLOOIJAkiGgxjpGKiKMkbz7SN6zIawJcDwIK9W/HISxGBzdHTuBNOmcJVCyoUlk7CEAAh+QQJCwAAACwAAAAAEAALAAAFNSAgjqQIRRFUAo3jNGIkSdHqPI8Tz3V55zuaDacDyIQ+YrBH+hWPzJFzOQQaeavWi7oqnVIhACH5BAkLAAAALAAAAAAQAAsAAAUyICCOZGme1rJY5kRRk7hI0mJSVUXJtF3iOl7tltsBZsNfUegjAY3I5sgFY55KqdX1GgIAIfkECQsAAAAsAAAAABAACwAABTcgII5kaZ4kcV2EqLJipmnZhWGXaOOitm2aXQ4g7P2Ct2ER4AMul00kj5g0Al8tADY2y6C+4FIIACH5BAkLAAAALAAAAAAQAAsAAAUvICCOZGme5ERRk6iy7qpyHCVStA3gNa/7txxwlwv2isSacYUc+l4tADQGQ1mvpBAAIfkECQsAAAAsAAAAABAACwAABS8gII5kaZ7kRFGTqLLuqnIcJVK0DeA1r/u3HHCXC/aKxJpxhRz6Xi0ANAZDWa+kEAA7AAAAAAAAAAAA);
                height: 11px;
                width: 16px;
            }
        </style>
    </head>
    <body>
        <div id="nav" class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <span class="navbar-brand">VRPipe</span>
                    <ul class="nav navbar-nav nav-tabs" id="tabsections">
                        <li class="active"><a href="#home" data-toggle="tab">Home</a></li>
                        <li><a href="#status" data-toggle="tab">Status</a></li>
                        <li><a href="#graph" data-toggle="tab">Graph</a></li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="container">
            <div class="tab-content">
                <div id="home" class="tab-pane fade in active">
                    <div class="jumbotron">
                        <h1>Welcome, friend!</h1>
                        <p>You've successfully connected to your VRPipe server. This web interface will have many more features coming soon; the first two - checking status of your pipeline setups and looking at the graph database - can be accessed using the links in the navigation bar above.</p>
                    </div>
                </div>
                
                <div id="status" class="tab-pane fade">
                    <h3>Status</h3>
                </div>
                
                <div id="graph" class="tab-pane fade">
                    <div id ="top">
                        <h3>Graph</h3>
                        
                        <form data-bind="submit: runCypherQuery">
                            <div class="row">
                                <div class="col-xs-10">
                                    <div class="input-group">
                                        <span class="input-group-addon" data-toggle="tooltip" data-container="body" title="Enter a cypher query that returns nodes and/or properties. Be careful to limit your query if necessary.">cypher $</span>
                                        <input type="text" class="form-control" data-bind="value: cypherQuery">
                                        <span class="input-group-btn">
                                            <button class="btn btn-default" type="submit"><span class="glyphicon glyphicon-play-circle"></span></button>
                                        </span>
                                    </div>
                                </div>
                                <div class="col-xs-2">
                                    <div class="input-group">
                                        <span class="input-group-addon" data-toggle="tooltip" data-container="body" title="When clicking on a node to see its children, this is the maxium depth to search for those children.">max depth</span>
                                        <input type="text" class="form-control" data-bind="value: cypherQueryMaxDepth">
                                    </div>
                                </div>
                            </div>
                        </form>
                        
                        <div class="btn-toolbar" role="toolbar" style="margin-top: 15px; margin-bottom: 20px">
                            <div class="btn-group" data-toggle="buttons" data-bind="radio: startNodesOption">
                                <label class="btn btn-primary">
                                    <input type="radio" name="startNodesOptionGroup" value="roots">Roots
                                </label>
                            </div>
                            
                            <div class="btn-group" data-toggle="buttons" data-bind="radio: layoutOption">
                                <label class="btn btn-default disabled">Layout:</label> 
                                <label class="btn btn-default">
                                    <input type="radio" name="layoutOptionGroup" value="tree">Tree
                                </label>
                                <label class="btn btn-default">
                                    <input type="radio" name="layoutOptionGroup" value="circle">Circle
                                </label>
                                <label class="btn btn-default">
                                    <input type="radio" name="layoutOptionGroup" value="grid">Grid
                                </label>
                                <label class="btn btn-default">
                                    <input type="radio" name="layoutOptionGroup" value="force">Force
                                </label>
                            </div>
                        </div>
                        
                        <div id="grapherrors" data-bind="foreach: grapherror">
                            <div class="alert alert-danger fade in">
                                <p data-bind="text: $data"></p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="well">
                        <div id="nodeinfo" style="position: absolute;" data-container="body" data-toggle="popover" data-placement="auto right" data-html="true" data-trigger="manual"></div>
                        
                        <div class="btn-group-vertical" style="position: absolute; z-index: 9999" data-bind="foreach: nameSpaces">
                            <div class="btn-group">
                                <button type="button" class="btn btn-default dropdown-toggle" data-toggle="dropdown" data-bind="style: { backgroundColor: hsl }">
                                    <span data-bind="text: namespace"></span>
                                    <span class="caret"></span>
                                </button>
                                <ul class="dropdown-menu" role="menu" data-bind="foreach: labels">
                                    <li><div class="text-center" style="padding: 5px" data-bind="text: label, style: { backgroundColor: hsl }"></div></li>
                                </ul>
                            </div>
                        </div>
                        
                        <div id="cy" data-bind="loadingWhen: graphloading().length"></div>
                    </div>
                    
                    <div data-bind="loadingWhen: graphloading().length, if: resultStrings().length">
                        <div class="panel panel-default">
                            <div class="panel-heading">Values</div>
                            <div class="table-responsive">
                                <table class="table table-striped">
                                    <tbody data-bind="foreach: resultStrings">
                                        <tr>
                                            <td data-bind="text: $data"></td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                    
                    <div data-bind="loadingWhen: graphloading().length, if: nodes().length">
                        <div class="panel panel-default">
                            <div class="panel-heading">Nodes</div>
                            <div class="table-responsive">
                                <table class="table table-striped">
                                    <thead>
                                        <tr>
                                            <th>Namespace</th>
                                            <th>Label</th>
                                            <th>Properties</th>
                                            <th>Node ID</th>
                                        </tr>
                                    <thead>
                                    <tbody data-bind="foreach: nodes">
                                        <tr>
                                            <td data-bind="text: namespace"></td>
                                            <td data-bind="text: label"></td>
                                            <td data-bind="text: properties"></td>
                                            <td data-bind="text: nodeId"></td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                    
                    <div data-bind="loadingWhen: graphloading().length, if: relationships().length">
                        <div class="panel panel-default">
                            <div class="panel-heading">Relationships</div>
                            <div class="table-responsive">
                                <table class="table table-striped">
                                    <thead>
                                        <tr>
                                            <th>Type</th>
                                            <th>Start Node</th>
                                            <th>End Node</th>
                                            <th>Properties</th>
                                            <th>Relationship ID</th>
                                        </tr>
                                    <thead>
                                    <tbody data-bind="foreach: relationships">
                                        <tr>
                                            <td data-bind="text: type"></td>
                                            <td data-bind="text: startNode"></td>
                                            <td data-bind="text: endNode"></td>
                                            <td data-bind="text: properties"></td>
                                            <td data-bind="text: relationshipId"></td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <hr>
            
            <footer id="footer">
                <small>&copy; 2014 Genome Research Limited.</small>
            </footer>
        </div>
        
        <script type="text/javascript">
            // turn on bootstrap tooltips and popovers
            $('[data-toggle="tooltip"]').tooltip({'placement': 'top'});
            $('[data-toggle="popover"]').popover();
            
            // client-side routes for the main sections, which basically just
            // ensure that the correct tab is shown if user changes url in
            // browser
            var router = new Simrou();
            var route = router.addRoute('/home');
            route.get(function(event, params) {
                $('#tabsections a[href="#home"]').tab('show');
            });
            route = router.addRoute('/status');
            route.get(function(event, params) {
                $('#tabsections a[href="#status"]').tab('show');
            });
            route = router.addRoute('/graph');
            route.get(function(event, params) {
                $('#tabsections a[href="#graph"]').tab('show');
            });
            
            // we have a custom ko binding to handle our loading feedback
            // (from http://blog.greatrexpectations.com/2012/06/17/loading-placeholders-using-knockout-js/)
            ko.bindingHandlers.loadingWhen = {
                init: function (element) {
                    var $element = $(element),
                        currentPosition = $element.css("position")
                        $loader = $("<div>").addClass("loader").hide();
                    
                    //add the loader
                    $element.append($loader);
                    
                    //make sure that we can absolutely position the loader against the original element
                    if (currentPosition == "auto" || currentPosition == "static")
                        $element.css("position", "relative");

                    //center the loader
                    $loader.css({
                        position: "absolute",
                        top: "20px",
                        left: "50%",
                        "margin-left": -($loader.width() / 2) + "px"
                    });
                },
                update: function (element, valueAccessor) {
                    var isLoading = ko.utils.unwrapObservable(valueAccessor()),
                        $element = $(element),
                        $childrenToHide = $element.children(":not(div.loader)"),
                        $loader = $element.find("div.loader");

                    if (isLoading) {
                        $childrenToHide.css("visibility", "hidden").attr("disabled", "disabled");
                        $loader.fadeIn("slow");
                    }
                    else {
                        $loader.fadeOut("fast");
                        $childrenToHide.css("visibility", "visible").removeAttr("disabled");
                    }
                }
            };
            
            // ajax function to send/get json queries
            var call = 1;
            var ajax = function(uri, method, loading, error, data) {
                var loadingTimeout;
                var request = {
                    url: uri,
                    type: method,
                    contentType: "application/json",
                    accepts: "application/json",
                    cache: false,
                    dataType: 'json',
                    data: JSON.stringify(data),
                    beforeSend: function (xhr) {
                        // say that we're loading, but only if for more than
                        // half a second
                        if (loadingTimeout) { clearTimeout(loadingTimeout); }
                        loadingTimeout = setTimeout(function() {
                            loading.push(true);
                        }, 500);
                        
                        xhr.setRequestHeader("X-Stream", "true");
                    },
                    error: function(jqXHR, textStatus, errorThrown) {
                        if (textStatus) {
                            var msg = "Ajax " + textStatus + " " + jqXHR.status + " connecting to " + uri;
                            if (errorThrown) {
                                msg = msg + ": " + errorThrown;
                            }
                            error.push(msg);
                        }
                    },
                    complete: function(jqXHR, textStatus) {
                        if (loadingTimeout) { clearTimeout(loadingTimeout); }
                        loading.pop();
                    }
                };
                return $.ajax(request);
            }
            
            // viewmodel for status
            function StatusViewModel() {
                var self = this;
                
                // pipelinesetup status stuff
            }
            
            // viewmodel for graph
            function GraphViewModel() {
                var self = this;
                self.nodes = ko.observableArray();
                self.relationships = ko.observableArray();
                self.resultStrings = ko.observableArray();
                self.cypherQuery = ko.observable();
                self.cypherQueryMaxDepth = ko.observable();
                self.layoutOption = ko.observable();
                self.nextHue = 0;
                self.namespaceToHSL = {};
                self.labelToHSL = {};
                self.nameSpaces = ko.observableArray();
                self.deploymentLabel = '%%deploymentLabel%%';
                self.schemas = {};
                self.graphloading = ko.observableArray();
                self.grapherror = ko.observableArray();
                
                // while cytoscape has the ability to add and remove nodes from a
                // graph, I can't figure out how to re-apply the breadthfirst, so
                // for now we'll just store the cytoscape options here and recreate
                // new cytoscape object for every graph update
                self.cytoscapeOptions = {
                    container: $('#cy')[0],
                    
                    userZoomingEnabled: 0,
                    
                    style: [
                        {
                            selector: 'node',
                            css: {
                                'content': 'data(displayName)',
                                'font-family': 'helvetica',
                                'font-size': 12,
                                'text-outline-width': 2,
                                'text-outline-color': '#888',
                                'text-valign': 'center',
                                'color': '#fff',
                                'border-color': 'data(lineColor)',
                                'border-width': 2,
                                'background-color': 'data(bgColor)'
                            }
                        },
                        
                        {
                            selector: ':selected',
                            css: {
                                'background-color': '#000',
                                'line-color': '#000',
                                'target-arrow-color': '#000',
                                'text-outline-color': '#000'
                            }
                        },
                        
                        {
                            selector: 'edge',
                            css: {
                                'width': 2,
                                'target-arrow-shape': 'triangle',
                                'content': 'data(type)',
                                'font-size': 8
                            }
                        }
                    ]
                };
                
                // we'll display our cytoscape graph on the #cy div, making it
                // fill the remaining vertical space
                $(document).ready(function() {
                    var $nav = $('#nav');
                    var $top = $('#top'); // on initial page load with the graph tab hidden, this is 0 instead of ~135
                    var $cy = $('#cy');
                    $(window).on('resize', function(){
                       var height = $(this).height() - $nav.outerHeight() - 135 - 100;
                       $cy.height(height);
                       self.plotCytoscape();
                    }).trigger('resize');
                });
                
                // we want different labels to get different colors, so here's
                // a function to get the next most different hsl (from
                // http://ridiculousfish.com/blog/posts/colors.html)
                self.getHSL = function() {
                    var idx = self.nextHue++;
                    var bitcount = 31;
                    var ridx = 0, i = 0;
                    for (i=0; i < bitcount; i++) {
                        ridx = (ridx << 1) | (idx & 1);
                        idx >>>= 1;
                    }
                    var hue = ridx / Math.pow(2, bitcount);
                    hue = (hue + .1) % 1;
                    var degrees = Math.round(hue * 360);
                    return 'hsl(' + degrees + ', 75%, 75%)';
                }
                
                // functions to create cytoscape nodes and plot them
                self.plotCytoscape = function() {
                    if (! self.layoutOption()) {
                        self.layoutOption('tree');
                    }
                    if (self.layoutOption() == 'tree') {
                        self.cytoscapeOptions.layout = {
                            name: 'breadthfirst',
                            fit: true,
                            ready: undefined,
                            stop: undefined,
                            directed: true,
                            padding: 30,
                            circle: false,
                            roots: undefined,
                            maximalAdjustments: 0
                        };
                    }
                    else if (self.layoutOption() == 'circle') {
                        self.cytoscapeOptions.layout = {
                            name: 'circle',
                            fit: true,
                            ready: undefined,
                            stop: undefined,
                            rStepSize: 10,
                            padding: 30,
                            startAngle: 3/2 * Math.PI,
                            counterclockwise: false
                        };
                    }
                    else if (self.layoutOption() == 'grid') {
                        self.cytoscapeOptions.layout = {
                            name: 'grid',
                            fit: true,
                            padding: 30,
                            rows: undefined,
                            columns: undefined,
                            position: function( node ){},
                            ready: undefined,
                            stop: undefined
                        };
                    }
                    else if (self.layoutOption() == 'force') {
                        self.cytoscapeOptions.layout = {
                            name: 'cose',
                            fit: true, 
                            ready: undefined,
                            stop: undefined,
                            refresh: 0,
                            padding: 30,
                            randomize: true,
                            debug: false,
                            nodeRepulsion: 10000,
                            nodeOverlap: 10000,
                            idealEdgeLength: 50,
                            edgeElasticity: 1000,
                            nestingFactor: 1,
                            gravity: 1,
                            numIter: 10000,
                            initialTemp: 10000,
                            coolingFactor: 0.95,
                            minTemp: 1
                        };
                    }
                    
                    return cytoscape(self.cytoscapeOptions);
                }
                
                self.createCytoscapeNodesAndPlot = function(nodeData, labelData, rootNodes) {
                    for (var i = 0; i < nodeData.length; i++) {
                        var node = nodeData[i];
                        var uniqueParam = self.schemas[node.schemaLabels];
                        var displayName = node.label;
                        if (uniqueParam && node.properties[uniqueParam]) {
                            displayName = node.properties[uniqueParam];
                        }
                        
                        self.cytoscapeOptions.elements.nodes.push({ data: { id: node.nodeId, displayName: displayName, label: node.label, namespace: node.namespace, properties: node.properties, bgColor: node.labelHSL, lineColor: node.nameSpaceHSL } });
                    }
                    
                    var cy = self.plotCytoscape();
                    
                    $.each(labelData, function(namespace, nsObj) {
                        var result = { namespace: namespace, hsl: nsObj.hsl, labels: Array() };
                        
                        // get the correct order of labels to make
                        // the colour key
                        var labelCount = 0;
                        for (x in nsObj.labels) {
                            labelCount++;
                        }
                        var currentCount = 0;
                        var labelOrder = {};
                        var orderLabel = Array();
                        var order = 1;
                        var roots = rootNodes[namespace];
                        for (var i = 0; i < roots.length; i++) {
                            var done = cy.elements().dfs('#' + roots[i], function(i, depth) {
                                var thisLabel = this.data('label');
                                if (! labelOrder.hasOwnProperty(thisLabel)) {
                                    labelOrder[thisLabel] = order++;
                                    orderLabel.push(thisLabel);
                                    
                                    currentCount++;
                                    if (currentCount == labelCount) {
                                        return true;
                                    }
                                }
                            }, true);
                            if (done) { break; }
                        }
                        
                        for (i in orderLabel) {
                            var label = orderLabel[i];
                            result.labels.push({ label: label, hsl: nsObj.labels[label] });
                        }
                        self.nameSpaces.push(result);
                    });
                }
                
                // function to get all nodes from a cypher query, and their
                // connecting relationships
                self.cypherURI = '%%cypherURI%%';
                self.cypherNodes = function(cypherJSON) {
                    ajax(self.cypherURI, 'POST', self.graphloading, self.grapherror, cypherJSON).done(function(data) {
                        var nodeProperties = Array();
                        var nodeIds = Array();
                        var labelRequests = Array();
                        var relationshipRequests = Array();
                        var schemaRequests = Array();
                        var schemaLabelsArray = Array();
                        var doneNeos = {};
                        for (var i = 0; i < data.data.length; i++) {
                            for (var j = 0; j < data.data[i].length; j++) {
                                if (data.data[i][j] != null) {
                                    if (typeof data.data[i][j] == "string") {
                                        // query must be returning strings
                                        // instead of nodes or relationships
                                        self.resultStrings.push(data.data[i][j]);
                                    }
                                    else {
                                        var neoself = data.data[i][j].self;
                                        if (neoself) {
                                            var neoid = neoself.match(/(\d+)$/)[0];
                                            
                                            if (! doneNeos.hasOwnProperty(neoself)) {
                                                var labels = data.data[i][j].labels;
                                                if (labels) {
                                                    nodeIds.push(neoid);
                                                    nodeProperties.push(data.data[i][j].data);
                                                    labelRequests.push(ajax(labels, 'GET', self.graphloading, self.grapherror));
                                                    relationshipRequests.push(ajax(data.data[i][j].all_relationships, 'GET', self.graphloading, self.grapherror));
                                                }
                                                doneNeos[neoself] = 1;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        if (relationshipRequests.length) {
                            var defer = $.when.apply($, relationshipRequests);
                            defer.done(function() {
                                // create all the relationships for our nodes
                                var nonRootNodes = { };
                                $.each(arguments, function(index, data) {
                                    var reldata;
                                    if (relationshipRequests.length == 1) {
                                        reldata = data;
                                    }
                                    else {
                                        reldata = data[0];
                                    }
                                    
                                    if (index < relationshipRequests.length) {
                                        for (var i = 0; i < reldata.length; i++) {
                                            var neoself = reldata[i].self;
                                            var neoid = neoself.match(/(\d+)$/)[0];
                                            
                                            if (! doneNeos.hasOwnProperty(neoself)) {
                                                if (doneNeos.hasOwnProperty(reldata[i].start) && doneNeos.hasOwnProperty(reldata[i].end)) {
                                                    var start = reldata[i].start.match(/(\d+)$/)[0];
                                                    var end = reldata[i].end.match(/(\d+)$/)[0];
                                                    var type = reldata[i].type;
                                                    self.relationships.push({
                                                        type: type,
                                                        startNode: start,
                                                        endNode: end,
                                                        properties: JSON.stringify(reldata[i].data),
                                                        relationshipId: neoid
                                                    });
                                                    
                                                    self.cytoscapeOptions.elements.edges.push({ data: { source: start, target: end, type: type } });
                                                    nonRootNodes[end] = 1;
                                                }
                                                doneNeos[neoself] = 1;
                                            }
                                        }
                                    }
                                });
                                
                                // get the labels for our nodes and create them
                                var defer2 = $.when.apply($, labelRequests);
                                defer2.done(function() {
                                    var tempNodes = Array();
                                    var rootNodes = {};
                                    var tempLabelData = {};
                                    $.each(arguments, function(index, data) {
                                        var labeldata;
                                        if (labelRequests.length == 1) {
                                            labeldata = data;
                                        }
                                        else {
                                            labeldata = data[0];
                                        }
                                        
                                        if (index < labelRequests.length) {
                                            if ($.inArray(self.deploymentLabel, labeldata) != -1) {
                                                var arr = labeldata[1].split('|');
                                                var namespace = arr[1];
                                                var label = arr[2];
                                                if (! label) {
                                                    arr = labeldata[0].split('|');
                                                    namespace = arr[1];
                                                    label = arr[2];
                                                }
                                                
                                                if (label) {
                                                    var schemaLabels = '`' + self.deploymentLabel + '`:`Schema`';
                                                    var dsl = self.deploymentLabel + '|' + namespace + '|' + label;
                                                    if (! self.schemas.hasOwnProperty(dsl)) {
                                                        schemaRequests.push(ajax(self.cypherURI, 'POST', self.graphloading, self.grapherror, { query: 'MATCH (n:' + schemaLabels + ' { schema: "' + dsl + '" }) RETURN n.unique' }));
                                                        schemaLabelsArray.push(dsl);
                                                        self.schemas[dsl] = 'placeholder';
                                                    }
                                                    
                                                    var nameSpaceHSL;
                                                    if (! self.namespaceToHSL.hasOwnProperty(namespace)) {
                                                        nameSpaceHSL = self.getHSL();
                                                        self.namespaceToHSL[namespace] = nameSpaceHSL;
                                                    }
                                                    else {
                                                        nameSpaceHSL = self.namespaceToHSL[namespace];
                                                    }
                                                    if (! tempLabelData.hasOwnProperty(namespace)) {
                                                        tempLabelData[namespace] = { hsl: nameSpaceHSL, labels: {} };
                                                    }
                                                    
                                                    var labelHSL;
                                                    if (! self.labelToHSL.hasOwnProperty(label)) {
                                                        labelHSL = self.getHSL();
                                                        self.labelToHSL[label] = labelHSL;
                                                    }
                                                    else {
                                                        labelHSL = self.labelToHSL[label];
                                                    }
                                                    if (! tempLabelData[namespace].labels.hasOwnProperty(label)) {
                                                        tempLabelData[namespace].labels[label] = labelHSL;
                                                    }
                                                    
                                                    // this is just for the tabular
                                                    // display of node data
                                                    self.nodes.push({
                                                        label: label,
                                                        namespace: namespace,
                                                        properties: JSON.stringify(nodeProperties[index]),
                                                        nodeId: nodeIds[index]
                                                    });
                                                    
                                                    // push out the info we need
                                                    // later to make the cytoscape
                                                    // nodes, once we have the
                                                    // schema data
                                                    tempNodes.push({
                                                        label: label,
                                                        namespace: namespace,
                                                        properties: nodeProperties[index],
                                                        nodeId: nodeIds[index],
                                                        schemaLabels: dsl,
                                                        nameSpaceHSL: nameSpaceHSL,
                                                        labelHSL: labelHSL,
                                                    });
                                                    
                                                    if (! nonRootNodes.hasOwnProperty(nodeIds[index])) {
                                                        if (! rootNodes.hasOwnProperty(namespace)) {
                                                            rootNodes[namespace] = Array();
                                                        }
                                                        rootNodes[namespace].push(nodeIds[index]);
                                                    }
                                                }
                                            }
                                        }
                                    });
                                    
                                    // create nodes and plot
                                    if (schemaRequests.length) {
                                        // add to our hash of schemaLabel => unique parameter name
                                        var defer3 = $.when.apply($, schemaRequests);
                                        defer3.done(function() {
                                            $.each(arguments, function(index, data) {
                                                var schemadata;
                                                if (schemaRequests.length == 1) {
                                                    schemadata = data;
                                                }
                                                else {
                                                    schemadata = data[0];
                                                }
                                                
                                                if (index < schemaRequests.length) {
                                                    var arr = schemadata.data[0][0].split('|');
                                                    self.schemas[schemaLabelsArray[index]] = arr[0];
                                                }
                                            });
                                            self.createCytoscapeNodesAndPlot(tempNodes, tempLabelData, rootNodes);
                                        });
                                    }
                                    else {
                                        self.createCytoscapeNodesAndPlot(tempNodes, tempLabelData, rootNodes);
                                    }
                                });
                            });
                        }
                    });
                }
                
                // "start" node queries: nodes that have no relationships in a
                // certain direction (incoming or outgoing)
                self.noOutgoingCypher = "MATCH (n:VRPipe) OPTIONAL MATCH n-[r]->() WITH n,r WHERE r IS NULL RETURN n LIMIT 100";
                self.noIncomingCypher = "MATCH (n:VRPipe) OPTIONAL MATCH n<-[r]-() WITH n,r WHERE r IS NULL RETURN n LIMIT 100";
                self.startNodesOption = ko.observable();
                
                // operations
                self.retrieveAndDisplayNodes = function(cypher) {
                    self.grapherror.removeAll();
                    self.nodes.removeAll();
                    self.relationships.removeAll();
                    self.resultStrings.removeAll();
                    self.nameSpaces.removeAll();
                    self.cytoscapeOptions.elements = {
                        nodes: [ ],
                        edges: [ ]
                    };
                    self.cypherNodes({ query: cypher });
                }
                self.runCypherQuery = function() {
                    if (self.cypherQuery()) {
                        self.startNodesOption(undefined);
                        location.hash = '/graph/cypher=' + self.cypherQuery();
                    }
                }
                
                // trigger route when choice of start node type changes
                self.startNodesOption.subscribe(function(newValue) {
                    if (newValue) {
                        location.hash = '/graph/start=' + newValue;
                    }
                });
                
                // update graph when choice of layout changes
                self.layoutOption.subscribe(function(newValue) {
                    if (newValue) {
                        self.plotCytoscape();
                    }
                });
                
                self.cypherQueryMaxDepth.subscribe(function(newValue) {
                    if (newValue) {
                        self.cytoscapeOptions.ready = function(){
                            cy = this;
                            cy.fit();
                            cy.$('node').one('tap', function(e){
                                var ele = e.cyTarget;
                                var cypher = 'START a=node(' + ele.id() + ') MATCH (c)-[*0..1]->(a)-[*0..' + self.cypherQueryMaxDepth() + ']->(b) RETURN distinct a,b,c';
                                self.cypherQuery(cypher);
                                location.hash = '/graph/cypher=' + self.cypherQuery();
                            });
                            
                            // change node color on mouseover; I don't know how
                            // or if this can be done in the main style option
                            // like :selected is defined. Cytoscape doesn't
                            // support changing the cursor anyway. And we also
                            // show a popover with the node details
                            cy.$('node').on('tapdragover', function(e) {
                                var node = e.cyTarget;
                                $('#nodeinfo').data('bs.popover').options.title = '<div class="text-center">' + node.data('namespace') + '|' + node.data('label') + ' {node ' + node.id() + '}</div>';
                                var nodeProperties = '<table class="table table-bordered table-striped table-condensed" style="margin-bottom: 0"><tbody>';
                                $.each(node.data('properties'), function(key, value) {
                                    nodeProperties = nodeProperties + '<tr><th>' + key + '</th><td>' + value + '</td></tr>';
                                });
                                nodeProperties = nodeProperties + '</tbody></table>';
                                $('#nodeinfo').data('bs.popover').options.content = nodeProperties;
                                
                                node.css('background-color', '#888');
                                $('#cy').css('cursor', 'pointer');
                                $(document).mousemove(function(event) {
                                    $("#nodeinfo").css({left: event.pageX + 40, top: event.pageY});
                                    $('#nodeinfo').popover('show');
                                    $(document).off('mousemove');
                                });
                            });
                            cy.$('node').on('tapdragout tap', function(e) {
                                var node = e.cyTarget;
                                node.css('background-color', node.data('bgColor'));
                                $('#cy').css('cursor', 'default');
                                $('#nodeinfo').popover('hide');
                            });
                        }
                        self.plotCytoscape();
                    }
                });
                if (! self.cypherQueryMaxDepth()) {
                    self.cypherQueryMaxDepth(2);
                }
                
                // client-side routes
                route = router.addRoute('/graph/start=:startNodesOption');
                route.get(function(event, params) {
                    $('#tabsections a[href="#graph"]').tab('show');
                    self.cypherQuery(undefined);
                    self.startNodesOption(params.startNodesOption); // to update ui if url changed manually in browser
                    if (params.startNodesOption == "leaves") {
                        self.retrieveAndDisplayNodes(self.noOutgoingCypher);
                    }
                    else if (params.startNodesOption == "roots") {
                        self.retrieveAndDisplayNodes(self.noIncomingCypher);
                    }
                });
                route = router.addRoute('/graph/cypher=:cypherQuery');
                route.get(function(event, params) {
                    $('#tabsections a[href="#graph"]').tab('show');
                    self.startNodesOption(undefined);
                    self.cypherQuery(decodeURIComponent(params.cypherQuery));
                    self.retrieveAndDisplayNodes(self.cypherQuery());
                });
            }
            var gvm = new GraphViewModel();
            ko.applyBindings(gvm, $('#graph')[0]);
            
            router.start('/home');
            
            // sync up url when we change section tabs using the UI
            $('a[data-toggle="tab"]').on('show.bs.tab', function(e) {
                var activeTab = $(e.target).text(); // Get the name of active tab
                if (activeTab == "Home") {
                    location.hash = '/home';
                }
                else if (activeTab == "Status") {
                    location.hash = '/status';
                }
                else if (activeTab == "Graph") {
                    location.hash = '/graph' + (gvm.startNodesOption() ? ('/start=' + gvm.startNodesOption()) : '');
                }
            });
        </script>
    </body>
</html>
