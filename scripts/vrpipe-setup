#!/usr/bin/env perl
use strict;
use warnings;

=head1 AUTHOR

Sendu Bala <sb10@sanger.ac.uk>.

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2011-2012 Genome Research Limited.

This file is part of VRPipe.

VRPipe is free software: you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program. If not, see L<http://www.gnu.org/licenses/>.

=cut

use VRPipe::FrontEnd;
use POSIX qw(getgroups);
use VRPipe::StepStatsUtil;

my $frontend = VRPipe::FrontEnd->new(
    description => "Setup a new pipeline, or alter the configuration of an existing one.",
    opt_spec    => [
        [],
        [q[Run with no options to create a new PipelineSetup.]],
        ['based_on=s', 'Provide the name or id of an existing PipelineSetup to create a new PipelineSetup based on it', { persistent_object => 'PipelineSetup' }],
        [q[(--extra_options can also be used here; see below)]],
        [],
        [q[To alter an existing PipelineSetup you will need to know its name or id; you can find these using:]],
        ['list|l',   'Just list out the setup names and ids, so you can subsequently rerun using --setup'],
        ['user|u=s', q[When listing setups, only list those created by this user. When creating a setup, create for this user (defaults to your current username, specify 'all' to see setups from all users)], { default => getlogin || getpwuid($<) }],
        [],
        [q[To alter an existing PipelineSetup:]],
        ['setup=s',       'Change the given pipeline setup (by id or name)', { persistent_object => 'PipelineSetup' }],
        ['extra_options', q[Be given the option to override step resource requirements (eg. memory needed), and to limit the number of jobs for a step that run simultaneously]],
        ['deactivate',    'Turn off the given --setup'],
        ['reactivate',    'Turn on the given --setup'],
        ['touch',         'Force a refresh of the dataelements corresponding to the given --setup'],
        ['reset',         'Wipe out all progress on the --setup, returning everything to the state it was just after you first created the setup, and leaves it in a deactivated state'],
        ['cleanup',       'Like --reset, but only for DataElements that are now withdrawn (use to recover wasted disk space)'],
        ['delete',        'Like --reset, but also delete the pipelinesetup itself so there is no trace you ever even created it']
    ]
);

my $user          = $frontend->opts('user');
my $setup         = $frontend->get_pipelinesetups();
my $extra_options = $frontend->opts('extra_options');
my $deactivate    = $frontend->opts('deactivate');
my $reactivate    = $frontend->opts('reactivate');
my $touch         = $frontend->opts('touch');
my $reset         = $frontend->opts('reset');
my $cleanup       = $frontend->opts('cleanup');
my $delete        = $frontend->opts('delete');
my $list          = $frontend->opts('list');
my $based_on      = $frontend->opts('based_on');

if ($setup && $list) {
    $frontend->error("--setup and --list don't make sense together; ignoring --list");
    $list = 0;
}
if ($user eq 'all' && !$list) {
    $frontend->die_with_error("--user all when not listing with --list don't make sense; when creating a new setup set a real user name with --user, or leave it to the default");
}
if (($deactivate || $reactivate) && !$setup) {
    $frontend->error("--deactivate and --activate only make sense when given a --setup; ignoring them");
    undef $deactivate;
    undef $reactivate;
}
if ($deactivate && $reactivate) {
    $frontend->die_with_error("--deactivate and --activate are mutually exclusive");
}

if ($setup) {
    # are we de/reactivating it?
    if ($deactivate || $reactivate) {
        if ($deactivate) {
            $setup->active(0);
            $setup->log_event("vrpipe-setup --deactivated called");
        }
        elsif ($reactivate) {
            $setup->active(1);
            $setup->log_event("vrpipe-setup --reactivated called");
        }
        $setup->update;
        
        my $active = $setup->active;
        
        $frontend->output("The 'active' state of PipelineSetup '", $setup->name, "' (id ", $setup->id, ") is now $active");
    }
    elsif ($reset || $cleanup || $delete) {
        my $question = $cleanup ? "Are you really sure you want to wipe out all work done on withdrawn DataElements of this setup? All their output files will be deleted!" : "Are you really sure you want to wipe out all progress on this setup? All output files will be deleted!";
        my $go_ahead = $frontend->ask_question(question => $question, possibles => [qw(y n)], required => 1);
        if ($go_ahead eq 'n') {
            $frontend->output("Abandoning this request, no harm done");
            exit;
        }
        
        my $setup_id = $setup->id;
        $frontend->output($cleanup ? "Working on wiping out all trace of the withdrawn DataElements of setup $setup_id..." : "Working on wiping out all trace of setup $setup_id...");
        my $mode_name = $cleanup ? "cleanup" : ($reset ? "reset" : "delete");
        
        # deactivate it first
        unless ($cleanup) {
            $setup->active(0);
            $setup->update;
            $setup->log_event("vrpipe-setup --$mode_name deactivated the PipelineSetup");
        }
        
        # delete all related rows in the db
        my @step_members = $setup->pipeline->step_members;
        my $estates_pager = $setup->dataelementstates_pager($cleanup ? (only_withdrawn => 1) : (include_withdrawn => 1));
        my @jobs_to_delete;
        while (my $estates = $estates_pager->next) {
            foreach my $element_state (@$estates) {
                $frontend->progress_indicator;
                
                my $element = $element_state->dataelement;
                foreach my $stepm (@step_members) {
                    my ($step_state) = VRPipe::StepState->search({ stepmember => $stepm, dataelement => $element, pipelinesetup => $setup });
                    $step_state || next;
                    
                    # delete all the step_state's submissions, and their job if
                    # not also used by some other setup
                    unless ($step_state->same_submissions_as) {
                        foreach my $sub ($step_state->submissions) {
                            my $job = $sub->job;
                            
                            my @job_subs = VRPipe::Submission->search({ job => $job->id }, { prefetch => { stepstate => 'pipelinesetup' } });
                            my $all_mine = 1;
                            foreach my $other_sub (@job_subs) {
                                if ($other_sub->stepstate->pipelinesetup->id != $setup_id) {
                                    $all_mine = 0;
                                    last;
                                }
                            }
                            
                            if ($all_mine) {
                                $setup->log_event("vrpipe-setup --$mode_name will kill Job because it is unique to this Setup", dataelement => $step_state->dataelement->id, stepstate => $step_state->id, submission => $sub->id, job => $job->id);
                                $job->kill_job unless $job->end_time;
                            }
                            
                            # delete any stepstats for the submission
                            foreach my $ss (VRPipe::StepStats->search({ submission => $sub->id })) {
                                $ss->delete;
                            }
                            
                            $setup->log_event("vrpipe-setup --$mode_name will delete Submission", dataelement => $step_state->dataelement->id, stepstate => $step_state->id, submission => $sub->id, job => $job->id);
                            $sub->delete;
                            push(@jobs_to_delete, $job) if $all_mine;
                        }
                    }
                    
                    # delete output files not also created by some other setup
                    $setup->log_event("vrpipe-setup --$mode_name will unlink all output files unique to this StepState", dataelement => $step_state->dataelement->id, stepstate => $step_state->id);
                    $step_state->unlink_output_files(only_unique_to_us => 1);
                    
                    # delete sofs
                    foreach my $sof ($step_state->_output_files) {
                        $sof->delete;
                    }
                    
                    # undef any same_submissions_as that reference us
                    VRPipe::StepState->search_rs({ same_submissions_as => $step_state->id })->update({ same_submissions_as => undef });
                    
                    $setup->log_event("vrpipe-setup --$mode_name will delete the StepState", dataelement => $step_state->dataelement->id, stepstate => $step_state->id);
                    $step_state->delete;
                }
                
                my $dataelement = $element_state->dataelement;
                $setup->log_event("vrpipe-setup --$mode_name will delete the DataElementState", dataelement => $dataelement->id);
                $element_state->delete;
                if ($cleanup) {
                    eval {
                        $setup->log_event("vrpipe-setup --$mode_name will delete the DataElement", dataelement => $dataelement->id);
                        $dataelement->delete;
                    };
                }
            }
        }
        $frontend->progress_indicator(1);
        
        foreach my $job (@jobs_to_delete) {
            $setup->log_event("vrpipe-setup --$mode_name will delete Job because it is unique to this Setup", job => $job->id);
            $job->delete;
        }
        
        if ($cleanup) {
            $frontend->output("Setup $setup_id has been cleaned up.");
            $setup->log_event("vrpipe-setup --$mode_name has cleaned up the Setup");
        }
        else {
            # also delete the pipelinesetup and links if in delete mode
            if ($delete) {
                VRPipe::DataElementLink->search_rs({ pipelinesetup => $setup_id })->delete;
                $setup->delete;
                $setup->log_event("vrpipe-setup --$mode_name has deleted the Setup");
                $frontend->output("Setup $setup_id has been reset and deleted.");
            }
            else {
                $frontend->output("Setup $setup_id has been reset and is now deactivated.");
                $setup->log_event("vrpipe-setup --$mode_name has reset the Setup");
            }
        }
    }
    elsif ($touch) {
        my $datasource = $setup->datasource;
        $datasource->_changed_marker('undef');
        $datasource->update;
        $setup->log_event("vrpipe-setup --touch called");
        
        # for file-based datasource, we have to literally touch the file as well
        my $instance = $datasource->_source_instance;
        if ($instance->can('source_file')) {
            my $path = $instance->source_file->path->stringify;
            if (-e $path) {
                my $touched = utime(undef, undef, $path);
                unless ($touched) {
                    open(my $fh, '>>', $path);
                    close($fh);
                }
            }
        }
        
        $frontend->output("The datasource ", $datasource->id, " of PipelineSetup '", $setup->name, "' (id ", $setup->id, ") was touched. Elements for this setup will be refreshed");
    }
    else {
        # allow the user to change pipeline setup options
        
        # Get a list of all options possible, without duplication
        my %option_names;
        my $option_num = 0;
        my @options;
        my $pipeline = $setup->pipeline;
        foreach my $stepm ($pipeline->step_members) {
            my $step        = $stepm->step;
            my $option_defs = $step->options_definition;
            foreach my $key (sort keys %$option_defs) {
                next if exists $option_names{$key};
                $option_num++;
                $option_names{$key} = $option_num;
                
                my $step_option = $option_defs->{$key};
                $options[$option_num] = [$key, $step_option->description, $step_option->optional, $step_option->default_value, $step_option->allowed_values];
            }
            
            if ($extra_options) {
                # also give the generic memory/time etc. options user could set
                # for this step
                my $step_name = $step->name;
                foreach my $ref (['memory', 'MB'], ['time', 'seconds']) { #  cpus tmp_space local_space custom
                    my ($resource, $unit) = @$ref;
                    my $key = $step_name . '_' . $resource;
                    next if exists $option_names{$key};
                    $option_num++;
                    $option_names{$key} = $option_num;
                    my $ssu        = VRPipe::StepStatsUtil->new(step => $step);
                    my $rec_method = 'recommended_' . $resource;
                    my $rec        = $ssu->$rec_method();
                    my $current    = $rec ? ' (currently averaging ' . $rec . ')' : '';
                    $options[$option_num] = [$key, "Override the $resource requirement (in $unit) for the step '$step_name'$current", 1, '', []];
                }
                
                # and an option to limit the number of simultaneous jobs for this
                # step
                my $key = $step_name . '_max_simultaneous';
                unless (exists $option_names{$key}) {
                    $option_num++;
                    $option_names{$key} = $option_num;
                    $options[$option_num] = [$key, "Limit the number of simultaneous jobs for the step '$step_name'", 1, $step->max_simultaneous, []];
                }
            }
        }
        
        # also include behaviour options
        my $reg = behaviours_to_regulators(get_pipeline_behaviours($pipeline));
        foreach my $regulator (keys %$reg) {
            my (@methods, %steps);
            my $methods = $reg->{$regulator}->{methods};
            while (my ($method, $steps) = each %$methods) {
                push(@methods, $method);
                foreach my $step (%$steps) {
                    $steps{$step} = 1;
                }
            }
            my @steps = sort { $a <=> $b } keys %steps;
            
            my @defaults = keys %{ $reg->{$regulator}->{defaults} };
            my $default = @defaults == 1 ? $defaults[0] : 'mixed';
            
            $option_num++;
            $option_names{$regulator} = $option_num;
            $options[$option_num] = [$regulator, "Turn the behaviours (" . join(', ', @methods) . ") of steps (" . join(', ', @steps) . ") on (1) of off (0)", 1, "$default" ne 'mixed' ? $default : '', [0, 1]];
        }
        
        # allow changing of output root
        $option_num++;
        $option_names{output_root} = $option_num;
        $options[$option_num] = ['output_root', "Absolute path of the root directory that output files should go to", 0, sub { $setup->output_root->stringify }, []];
        my %specials;
        $specials{output_root} = 1;
        
        # allow changing group
        $option_num++;
        $option_names{group} = $option_num;
        $options[$option_num] = ['group', "Unix group that output files should belong to (no answer uses the default group of the user that runs vrpipe-server)", 1, sub { $setup->unix_group }, [map { scalar getgrgid($_) } getgroups]];
        $specials{group} = 1;
        
        # offer to maybe change datasource
        $option_num++;
        $option_names{datasource} = $option_num;
        $options[$option_num] = ['datasource', "Try to alter the DataSource", 0, sub { $setup->datasource->id }, []];
        $specials{datasource} = 1;
        
        if ($option_num) {
            $frontend->output("PipelineSetup '", $setup->name, "' (id ", $setup->id, ") currently has these options:");
            
            # Show the user the list, along with currently set options, allow them to
            # change an option, then repeat until they choose to finish
            while (1) {
                my $current_opts = $setup->options;
                foreach my $i (1 .. $option_num) {
                    my ($key, $desc, $optional, $default, $allowed) = @{ $options[$i] };
                    my $current = defined $current_opts->{$key} ? $current_opts->{$key} : '[not set]';
                    if (exists $specials{$key}) {
                        my $d = &{$default} if defined $default;
                        $current = $d if defined $d;
                        undef $default;
                    }
                    my $comment = $optional ? 'optional' : 'REQUIRED';
                    $frontend->output("$i. $key ($comment) => $current");
                    $frontend->output("\tDescription: $desc");
                    if ($default) {
                        $frontend->output("\tDefault: $default");
                    }
                    if (@$allowed) {
                        $frontend->output("\tAllowed values: ", join(' | ', @$allowed));
                    }
                }
                
                my $choice = $frontend->pick_number(question => "Choose an option to change", max => $option_num);
                my $chosen_key = $options[$choice]->[0];
                
                if ($chosen_key eq 'datasource') {
                    # allow changing the datasource, but only if a) no
                    # stepstates have been created yet, in which case we create
                    # a new ds, or b) no other setups use our datasource, in
                    # which case we alter the current ds
                    my $current_ds          = $setup->datasource;
                    my $got_current_ds_lock = $current_ds->lock;
                    if ($got_current_ds_lock) {
                        $current_ds->maintain_lock;
                        
                        my $other_setups    = VRPipe::PipelineSetup->search({ datasource => $current_ds->id });
                        my $set_new_ds      = 0;
                        my $have_stepstates = VRPipe::StepState->search({ pipelinesetup => $setup->id });
                        if (!$have_stepstates) {
                            $set_new_ds = 1;
                        }
                        elsif ($other_setups > 1) {
                            $frontend->output("Sorry, you can't alter the datasource because it is shared by other setups and this setup has already been triggered\n\n");
                        }
                        
                        if ($other_setups == 1 || $set_new_ds) {
                            # ask the user for the new ds settings
                            my ($chosen_ds_type, $chosen_method, $ds_source, $chosen_method_args) = get_ds_details($setup);
                            my %new_ds_args = (type => $chosen_ds_type, method => $chosen_method, source => $ds_source, options => $chosen_method_args);
                            
                            if ($set_new_ds) {
                                # try and clean up any existing des first, which
                                # are now invalid
                                eval { VRPipe::DataElementState->search_rs({ pipelinesetup => $setup->id })->delete; };
                                if ($@) {
                                    $frontend->output("Sorry, the setup's current datasource has some dataelementstates that couldn't be deleted: $@\n\n");
                                }
                                else {
                                    # create and set a new datasource
                                    my $new_ds = VRPipe::DataSource->create(%new_ds_args);
                                    $setup->datasource($new_ds);
                                    $setup->update;
                                    $frontend->output("The setup's datasource was replaced with a new one\n\n");
                                }
                            }
                            else {
                                # see if a ds corresponding to the new
                                # settings already exists
                                my $already_exists = 0;
                                my $transaction    = sub {
                                    my ($new_ds) = VRPipe::DataSource->search(\%new_ds_args);
                                    if ($new_ds && $new_ds->id != $current_ds->id) {
                                        $already_exists = $new_ds->id;
                                    }
                                };
                                $setup->do_transaction($transaction, "Could not search for DataSources");
                                
                                if ($already_exists) {
                                    $frontend->output("Sorry, I can't update the setup's datasource with your new settings, since they match those of another datasource for a different setup.\n\n");
                                }
                                else {
                                    # alter our current datasource
                                    $current_ds->type($chosen_ds_type);
                                    $current_ds->method($chosen_method);
                                    $current_ds->source($ds_source);
                                    $current_ds->options($chosen_method_args);
                                    $current_ds->_changed_marker('forced_update');
                                    $current_ds->update;
                                    $frontend->output("The setup's datasource was altered with the new settings\n\n");
                                }
                            }
                        }
                        
                        $current_ds->unlock;
                    }
                    else {
                        $frontend->output("Sorry, you can't alter the datasource right now because it is currently being updated or triggered\n\n");
                    }
                }
                else {
                    my $default = $options[$choice]->[3];
                    $default = &{$default} if $default && ref $default;
                    my $val = $frontend->ask_question(
                        question => "Provide a new value for '$chosen_key'",
                        required => $options[$choice]->[2] ? 0 : 1,
                        defined $default ? (default => $default) : (),
                        $options[$choice]->[4] ? (possibles => $options[$choice]->[4]) : ()
                    );
                    if ($chosen_key eq 'output_root') {
                        $setup->output_root($val);
                    }
                    elsif ($chosen_key eq 'group') {
                        $setup->unix_group($val);
                    }
                    else {
                        $current_opts->{$chosen_key} = $val;
                        $setup->options($current_opts);
                    }
                    $setup->update;
                    $frontend->output("Option updated!\n\n");
                }
                
                my $answer = $frontend->ask_question(question => "Do you want to change another option?", possibles => [qw(y n)], default => 'n');
                last unless $answer eq 'y';
                $frontend->output("\n");
            }
        }
        else {
            $frontend->output("PipelineSetup '", $setup->name, "' (id ", $setup->id, ") has no options that can be set (try rerunning with --extra_options ?).");
        }
    }
}
elsif ($list) {
    # list existing setups, including those that have been deactivated
    my $search_args;
    if ($user eq 'all') {
        $search_args = {};
    }
    else {
        $search_args = { user => $user };
    }
    foreach my $setup (VRPipe::PipelineSetup->search($search_args)) {
        my $active = $setup->active ? 'active' : 'inactive';
        $frontend->output("PipelineSetup '", $setup->name, "' (id ", $setup->id, ", $active for user ", $setup->user, ")");
    }
}
else {
    # allow the user to create a new setup
    my $pipeline;
    if ($based_on) {
        $pipeline = $based_on->pipeline;
        $frontend->output("Based on PipelineSetup ", $based_on->id, ", your new setup will use the pipeline '", $pipeline->name, "'");
    }
    else {
        $pipeline = $frontend->ask_for_object(question => "Pick a pipeline from the above list to run", class => 'Pipeline', column => 'name');
    }
    
    my @sms = $pipeline->step_members;
    unless (@sms) {
        # ensure that the chosen pipeline has actually been constructed
        VRPipe::Pipeline->create(name => $pipeline->name);
        @sms = $pipeline->step_members;
    }
    my @steps = map { $_->step } @sms;
    
    # find the steps whose input is the data element
    my @adaptors = VRPipe::StepAdaptor->search({ pipeline => $pipeline->id });
    my %source_input_step_num_to_kind;
    foreach my $adaptor (@adaptors) {
        my $hash = $adaptor->adaptor_hash;
        while (my ($kind, $ins_hash) = each %$hash) {
            if (exists $ins_hash->{data_element}) {
                push(@{ $source_input_step_num_to_kind{ $adaptor->to_step } }, $kind);
            }
        }
    }
    unless (keys %source_input_step_num_to_kind) {
        $frontend->die_with_error("Your chosen pipeline doesn't seem to accept any user input!");
    }
    
    # figure out what sort of input data is expected
    my %source_input_steps;
    foreach my $sm (@sms) {
        my $step_number = $sm->step_number;
        my @kinds = @{ $source_input_step_num_to_kind{$step_number} || next };
        foreach my $kind (@kinds) {
            $source_input_steps{ $step_number . '#' . $kind } = $sm->step;
        }
    }
    $frontend->output("Your chosen pipeline takes DataSource input during step(s):");
    foreach my $snk (sort { my ($n1, $s1) = split('#', $a); my ($n2, $s2) = split('#', $b); $n1 <=> $n2 || $s1 cmp $s2 } keys %source_input_steps) {
        my $source_input_step = $source_input_steps{$snk};
        my ($source_input_step_num, $source_input_step_kind) = split('#', $snk);
        my $source_input_io_def = $source_input_step->inputs_definition->{$source_input_step_kind};
        $frontend->output("\t$source_input_step_num (", $source_input_step->name, " - ", $source_input_step->description, "), which expects:");
        describe_io_def($source_input_io_def);
    }
    
    # ask the user for the DataSource details
    my ($chosen_ds_type, $chosen_method, $ds_source, $chosen_method_args) = get_ds_details($based_on);
    
    # pick pipeline (step) options
    my %step_options;
    my %step_option_order;
    my $soo_i = 0;
    my %step_extras;
    my @step_extras_order;
    foreach my $step (@steps) {
        my $step_name = $step->name;
        my $def       = $step->options_definition;
        while (my ($key, $vso) = each %$def) {
            unless (exists $step_options{$key}) {
                $soo_i++;
                $step_option_order{$soo_i} = $key;
            }
            
            push(@{ $step_options{$key}->{steps} }, $step_name);
            # *** how do we better handle different steps having the same option
            #     key but different vsos? Ignored for now; we just use the last
            $step_options{$key}->{vso} = $vso;
        }
        
        if ($extra_options) {
            # also give the generic memory/time etc. options user could set
            # for this step
            foreach my $ref (['memory', 'MB'], ['time', 'seconds']) { #  cpus tmp_space local_space custom
                my ($resource, $unit) = @$ref;
                my $key = $step_name . '_' . $resource;
                next if exists $step_extras{$key};
                push(@step_extras_order, $key);
                my $ssu        = VRPipe::StepStatsUtil->new(step => $step);
                my $rec_method = 'recommended_' . $resource;
                my $rec        = $ssu->$rec_method();
                my $current    = $rec ? ' (currently averaging ' . $rec . ')' : '';
                $step_extras{$key} = ["Override the $resource requirement (in $unit) for the step '$step_name'$current"];
            }
            
            # and an option to limit the number of simultaneous jobs for this
            # step
            my $key = $step_name . '_max_simultaneous';
            unless (exists $step_extras{$key}) {
                push(@step_extras_order, $key);
                $step_extras{$key} = ["Limit the number of simultaneous jobs for the step '$step_name'", $step->max_simultaneous];
            }
        }
    }
    my %pipeline_args;
    my $based_on_options;
    if ($based_on) {
        $based_on_options = $based_on->options;
    }
    if (keys %step_options) {
        $frontend->output("\nPlease provide options for the '", $pipeline->name, "' pipeline:");
        foreach my $soo_i (sort { $a <=> $b } keys %step_option_order) {
            my $key     = $step_option_order{$soo_i};
            my @steps   = @{ $step_options{$key}->{steps} };
            my $vso     = $step_options{$key}->{vso};
            my $comment = $vso->optional ? 'optional' : 'REQUIRED';
            $comment .= ', used by step';
            $comment .= 's' if @steps > 1;
            my $default;
            if ($based_on_options && defined $based_on_options->{$key}) {
                $default = $based_on_options->{$key};
            }
            else {
                $default = $vso->default_value;
            }
            my $arg = $frontend->ask_question(question => "\t$key ($comment " . join(", ", @steps) . ")\n\t" . $vso->description, possibles => $vso->allowed_values, default => $default, required => !$vso->optional); #*** could vso be altered so that it could actually validate the answer right away?...
            if (defined $arg && "$arg" ne '') {
                $pipeline_args{$key} = $arg;
            }
        }
    }
    if (keys %step_extras) {
        foreach my $key (@step_extras_order) {
            my ($desc, $default) = @{ $step_extras{$key} };
            if ($based_on_options && defined $based_on_options->{$key}) {
                $default = $based_on_options->{$key};
            }
            my $arg = $frontend->ask_question(question => "\t$key | $desc", $default ? (default => $default) : (), required => 0);
            if (defined $arg && $arg =~ /^\d+$/) {
                $pipeline_args{$key} = $arg;
            }
        }
    }
    if (!keys %step_options && !keys %step_extras) {
        $frontend->output("\n(the ", $pipeline->name, " pipeline has no options to set)");
    }
    
    # set regulations
    my $reg = behaviours_to_regulators(get_pipeline_behaviours($pipeline));
    if (keys %$reg) {
        $frontend->output("\nCertain behaviours of your pipeline are regulated by boolean keys:");
        foreach my $regulator (keys %$reg) {
            $frontend->output("\t'$regulator' key controls the behaviours:");
            my $methods = $reg->{$regulator}->{methods};
            while (my ($method, $steps) = each %$methods) {
                my @steps = sort { $a <=> $b } keys %$steps;
                $frontend->output("\t\t'$method' - acts on steps " . join(', ', @steps));
            }
            my @defaults = keys %{ $reg->{$regulator}->{defaults} };
            my $default;
            if ($based_on_options && defined $based_on_options->{$regulator}) {
                $default = $based_on_options->{$regulator};
            }
            else {
                $default = @defaults == 1 ? $defaults[0] : 'mixed';
            }
            my $regulation = $frontend->ask_question(question => "\tTurn this behaviour on (1) or off (0)?", possibles => [0, 1], "$default" ne 'mixed' ? (default => $default) : (required => 1));
            $pipeline_args{$regulator} = $regulation;
        }
    }
    
    # output root?
    my $output_root = $frontend->ask_question(question => "Please provide the absolute path to the root directory that output files will be written to", required => 1, $based_on ? (default => $based_on->output_root->stringify) : (), strip_leading_trailing_whitespace => 1);
    
    # group?
    my $group = $frontend->ask_question(question => "Which Unix group should output files should belong to (no answer uses the default group of the user that runs vrpipe-server)", required => 0, $based_on ? (default => $based_on->unix_group || '') : (), strip_leading_trailing_whitespace => 1);
    
    # what farm (vrpipe-server) should it run from?
    my $prev_desired_farm;
    if ($based_on && $based_on->desired_farm) {
        $prev_desired_farm = $based_on->desired_farm;
    }
    my $farm_default = $prev_desired_farm || 'random';
    my %farm_possibles = map { $_ => 1 } VRPipe::FarmServer->get_column_values('farm', {});
    $farm_possibles{$farm_default} = 1;
    my $farm = $frontend->ask_question(question => "Which vrpipe-server (identified by the 'farm' name) should the setup be controlled by (entering nothing means a random server will be used)", required => 0, possibles => [keys %farm_possibles], default => $farm_default);
    undef $farm if $farm eq 'random';
    my $farm_confirmation = $farm ? "controlled by farm '$farm'" : 'controlled by a random farm';
    
    # name?
    my $setup_name = $frontend->ask_question(question => "What would you like to call your new pipeline setup?", required => 1, not_allowed => \&VRPipe::FrontEnd::already_exists, na_args => [$frontend, 'PipelineSetup', 'name'], strip_leading_trailing_whitespace => 1);
    
    # confirm with the user everything is correct
    $frontend->output("\nWe've now gathered all information; here's what you've asked for:");
    $frontend->output("\tPipelineSetup name: $setup_name (for user $user $farm_confirmation)");
    $frontend->display_hash("\tDataSource: $chosen_ds_type\->$chosen_method with source $ds_source", $chosen_method_args);
    $frontend->display_hash("\tPipeline: " . $pipeline->name . " (outputting to $output_root " . ($group ? "belonging to group $group" : '') . ")", \%pipeline_args);
    
    my $correct = $frontend->ask_question(question => "Is all of this correct?", possibles => [qw(y n)], required => 1);
    
    # actually create the datasource and pipelinesetup
    if ($correct eq 'y') {
        my $ds = VRPipe::DataSource->create(type => $chosen_ds_type, method => $chosen_method, source => $ds_source, options => $chosen_method_args);
        my $ps = VRPipe::PipelineSetup->create(name => $setup_name, datasource => $ds, pipeline => $pipeline, output_root => $output_root, options => \%pipeline_args, user => $user, $group ? (unix_group => $group) : (), $farm ? (desired_farm => $farm) : ());
        $frontend->output("\nYour new PipelineSetup has been created!\nName: $setup_name; Id: ", $ps->id, " (remember at least one of these for use later)");
        $ps->log_event("vrpipe-setup used to create this new PipelineSetup");
    }
    else {
        $frontend->output("Abandoning the setup, nothing was done");
    }
}

exit;

sub describe_io_def {
    my $io_def = shift;
    
    $frontend->output("\t\tFile type = ", $io_def->type, " (", $io_def->description, ")");
    my $files_comment = $io_def->check_existence ? 'and they must exist' : "and they don't have to exist yet";
    my $max = $io_def->max_files;
    if ($max == -1) {
        $max = 'unlimited';
    }
    $frontend->output("\t\tNumber of files = ", $io_def->min_files, '..', $max, " ($files_comment)");
    my $metadata = $io_def->metadata;
    if (keys %$metadata) {
        $frontend->output("\t\tFiles must also have the following metadata associated with them (so be sure to pick a DataSource capable of adding this metadata):");
        my %optional = map { $_ => 1 } @{ delete $metadata->{optional} || [] };
        foreach my $key (sort keys %$metadata) {
            my $val = $metadata->{$key};
            my $comment = exists $optional{$key} ? 'optional' : 'REQUIRED';
            $frontend->output("\t\t\t$key => $val ($comment)");
        }
    }
}

sub get_pipeline_behaviours {
    my $pipeline = shift;
    return VRPipe::StepBehaviour->search({ pipeline => $pipeline->id });
}

sub behaviours_to_regulators {
    my %reg;
    foreach my $b (@_) {
        my $regulator = $b->regulated_by || next;
        my $array = $b->behaviour_array;
        foreach my $behaviour (@$array) {
            my ($method, @steps) = @$behaviour;
            foreach my $step (@steps) {
                $reg{$regulator}->{methods}->{$method}->{$step} = 1;
            }
        }
        $reg{$regulator}->{defaults}->{ $b->default_regulation } = 1;
    }
    
    return \%reg;
}

sub get_ds_details {
    my $based_on = shift;
    
    my @ds_types;
    my $ds_num = 0;
    $frontend->output("\n");
    my ($based_on_ds, $based_on_ds_type, $based_on_ds_type_num, $based_on_ds_method, $based_on_ds_method_num, $based_on_ds_options);
    if ($based_on) {
        $based_on_ds         = $based_on->datasource;
        $based_on_ds_type    = $based_on_ds->type;
        $based_on_ds_method  = $based_on_ds->method;
        $based_on_ds_options = $based_on_ds->options;
    }
    foreach my $ds_type ($frontend->sub_modules('DataSource')) {
        $ds_num++;
        my $ds_module = "VRPipe::DataSource::$ds_type";
        eval "require $ds_module;";
        if ($@) {
            die $@;
        }
        my $ds = $ds_module->new;
        $frontend->output("$ds_num. $ds_type (", $ds->description, ")");
        $ds_types[$ds_num] = $ds_type;
        
        if ($based_on_ds_type && $based_on_ds_type eq $ds_type) {
            $based_on_ds_type_num = $ds_num;
        }
    }
    my $chosen_ds_num = $frontend->pick_number(question => "Pick a DataSource type from the above list", max => $ds_num, $based_on_ds ? (default => $based_on_ds_type_num) : ());
    my $chosen_ds_type = $ds_types[$chosen_ds_num];
    if (defined $based_on_ds_type && $based_on_ds_type ne $chosen_ds_type) {
        undef $based_on_ds;
        undef $based_on_ds_type;
        undef $based_on_ds_method;
        undef $based_on_ds_options;
    }
    
    # get the source
    my $ds_module = "VRPipe::DataSource::$chosen_ds_type";
    my $ds        = $ds_module->new;
    $frontend->output("$chosen_ds_type DataSources have a source described as:\n", $ds->source_description);
    my $ds_source = $frontend->ask_question(question => "Supply the source", required => 1, $based_on_ds ? (default => $based_on_ds->source) : (), strip_leading_trailing_whitespace => 1);
    
    # pick a method
    $frontend->output("\n");
    my $chosen_method;
    my @method_names = $ds->get_methods;
    if (@method_names == 1) {
        $chosen_method = $method_names[0];
        $frontend->output("The $chosen_ds_type DataSource has only one method: $chosen_method (", $ds->method_description($chosen_method), ")");
    }
    else {
        my $method_num = 0;
        my @ds_methods;
        foreach my $method (@method_names) {
            $method_num++;
            $frontend->output("$method_num. $method (", $ds->method_description($method), ")");
            $ds_methods[$method_num] = $method;
            
            if ($based_on_ds_method && $based_on_ds_method eq $method) {
                $based_on_ds_method_num = $method_num;
            }
        }
        my $chosen_method_num = $frontend->pick_number(question => "Pick one of the $chosen_ds_type DataSource methods from the above list", max => $method_num, $based_on_ds ? (default => $based_on_ds_method_num) : ());
        $chosen_method = $ds_methods[$chosen_method_num];
    }
    
    # pick method options
    my %chosen_method_args;
    my @method_opts = $ds->method_options($chosen_method);
    if (@method_opts) {
        $frontend->output("\nPlease provide your options to the '$chosen_method' method:");
        foreach my $method_opt (@method_opts) {
            my ($kind, $name, $req, $default, $constraint) = @$method_opt;
            next unless $kind eq 'named';
            my $comment = $req ? 'REQUIRED' : 'optional';
            if ($based_on_ds_options && defined $based_on_ds_options->{$name}) {
                $default = $based_on_ds_options->{$name};
            }
            my $arg = $frontend->ask_question(question => "\t$name ($comment, a $constraint)", defined $default ? (default => $default) : (), required => $req);
            if (defined $arg && "$arg" ne '') {
                $chosen_method_args{$name} = $arg;
            }
        }
    }
    else {
        $frontend->output("(the '$chosen_method' method has no options)");
    }
    
    #*** check the source actually works, and works with the pipeline...
    
    return ($chosen_ds_type, $chosen_method, $ds_source, \%chosen_method_args);
}
