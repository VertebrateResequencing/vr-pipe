#!/usr/bin/env perl
use strict;
use warnings;

=head1 AUTHOR

Sendu Bala <sb10@sanger.ac.uk>.

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2012-2013 Genome Research Limited.

This file is part of VRPipe.

VRPipe is free software: you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program. If not, see L<http://www.gnu.org/licenses/>.

=cut

use EV;
use AnyEvent;
use AnyEvent::Util qw(fork_call);
use AnyEvent::ForkManager;
use Sys::CPU;
use VRPipe::FrontEnd;
use VRPipe::Interface::BackEnd;
use Proc::ProcessTable;
use Proc::Killfam;
use DateTime;

# handle options
my $cmdline = VRPipe::FrontEnd->new(
    description => "Handle the running of setups or submissions while executing on a farm node.",
    opt_spec    => [
        ['One of two modes must be specified, as must --farm.'],
        ['mode|m=s', 'setups|submissions - handle setups or submissions'],
        ['farm=s',   'Handle setups being controlled by this farm'],
        [],
        ['In --mode submissions, you must also supply either:'],
        ['submission=i', 'a Submission id, to directly specify a single Submission to handle', { persistent_object => 'Submission' }],
        ['Or, to potentially have it handle multiple Submissions, both of:'],
        ['requirements|r=i', 'a Requirements id, to handle any Submission with these requirements', { persistent_object => 'Requirements' }],
        ['scheduler|s=i',    'a Scheduler id',                                                      { persistent_object => 'Scheduler' }],
        [],
        ['debug',   'turn lots of debugging output on, and allow it to work without a server running'],
        ['setup=s', 'when --debug is on and you are in --mode setups, you can make it only look at a given setup']
    ]
);

my $max_forks = Sys::CPU::cpu_count();
my $farm = $cmdline->opts('farm') || $cmdline->die_with_error("--farm is required");

# initialize the VRPipe backend
my $deployment = $cmdline->opts('deployment');
my $backend    = VRPipe::Interface::BackEnd->new(deployment => $deployment, farm => $farm);
my $schema     = $backend->schema;
$AnyEvent::Util::MAX_FORKS = $max_forks;
my $debug = $cmdline->opts('debug');
my $im    = VRPipe::Persistent::InMemory->new();

# act on the given mode
my $mode = $cmdline->opts('mode') || $cmdline->die_with_error("--mode must be supplied");
my $fs;
unless ($debug) {
    ($fs) = VRPipe::FarmServer->search({ farm => $farm });
    unless ($fs) {
        $cmdline->die_with_error("There is no farm server running for farm '$farm'");
    }
}
if ($debug || $deployment eq 'testing') {
    $backend->set_verbose_global(1);
}

if ($mode eq 'setups') {
    my $setup_id = $cmdline->opts('setup');
    my ($setup) = $setup_id && $debug ? VRPipe::PipelineSetup->search({ id => $setup_id }) : undef;
    handle_setups($setup);
}
elsif ($mode eq 'submissions') {
    my ($req, $scheduler);
    my $given_sub = $cmdline->opts('submission');
    if ($given_sub) {
        $req       = $given_sub->requirements;
        $scheduler = $given_sub->scheduler;
    }
    else {
        $scheduler = $cmdline->opts('scheduler')    || $cmdline->die_with_error("--scheduler must be supplied if not --submission");
        $req       = $cmdline->opts('requirements') || $cmdline->die_with_error("--requirements must be supplied with --submission");
    }
    
    handle_submissions($req, $scheduler, $given_sub);
}
else {
    $cmdline->die_with_error("$mode is an invalid mode");
}

exit 0;

sub handle_setups {
    $im->log_stderr unless $debug;
    my $single_setup = shift;
    
    # every 30s we'll check for new setups we're supposed to handle, and also
    # confirm there is still a farmserver up for our farm (and exit if not)
    my %setups;
    my %datasource_watchers;
    my %setup_watchers;
    my $setups_timer_interval      = $deployment eq 'production' && !$debug ? 150  : 5;
    my $datasource_timer_interval  = $deployment eq 'production' && !$debug ? 300  : 10;
    my $setup_state_timer_interval = $deployment eq 'production' && !$debug ? 1800 : 15;
    my %currently_triggering;
    my $setups_watcher = EV::timer 0, $setups_timer_interval, sub {
        my @setups = ();
        eval {
            unless ($debug) { $fs->locked || die "no farmserver" }
            @setups = $single_setup ? ($single_setup) : VRPipe::PipelineSetup->search({ active => 1, controlling_farm => $farm }, { prefetch => ['datasource', 'pipeline'] });
        };
        if ($@) {
            if ($@ =~ /no farmserver/) {
                exit_handler("There is no longer a server for farm $farm");
            }
            else {
                exit_handler("There was a problem accessing the database: $@");
            }
        }
        else {
            if (@setups) {
                # remove handling and watchers for setups no longer active/
                # controlled by our farm
                my %current_setup_ids = map { $_->id => 1 } @setups;
                foreach my $stored_setup_id (keys %setups) {
                    unless (exists $current_setup_ids{$stored_setup_id}) {
                        my $ds_id = $setups{$stored_setup_id}->datasource->id;
                        $datasource_watchers{$ds_id}->{count}--;
                        delete $datasource_watchers{$ds_id} if $datasource_watchers{$ds_id}->{count} == 0;
                        delete $setup_watchers{$stored_setup_id};
                        delete $setups{$stored_setup_id};
                    }
                }
                
                # trigger new setups, in parallel
                my @new_setups;
                my $ds_working_sub = sub {
                    my ($ds_id, $err) = @_;
                    $err =~ s/^DataSource error: // if $err;
                    
                    foreach my $s (VRPipe::PipelineSetup->search({ datasource => $ds_id })) {
                        my $sid = $s->id;
                        my $mt = VRPipe::MessageTracker->create(subject => "datasource $ds_id state message for setup $sid");
                        
                        if ($err) {
                            # email user about the error once per setup
                            unless ($mt->already_sent("not working")) {
                                $s->log_event("vrpipe-handler for setups called found that DataSource $ds_id has problems: $err");
                                $im->log("There is a problem with datasource $ds_id for setup $sid", email_to => [$s->user], subject => "Setup $sid has problems with its DataSource", long_msg => $err);
                            }
                        }
                        else {
                            $mt->update_message("working fine");
                        }
                    }
                };
                
                foreach my $setup (@setups) {
                    my $sid = $setup->id;
                    next if exists $setups{$sid};
                    $setups{$sid} = $setup;
                    push(@new_setups, $setup);
                    
                    # (because I couldn't get AnyEvent::ForkManager->on_finish
                    #  to work, we use fork_calls instead)
                    $currently_triggering{$sid} = 1;
                    my $ds_id = $setup->datasource->id;
                    $datasource_watchers{$ds_id}->{working} = 1;
                    $setup->disconnect;
                    fork_call {
                        $im->debug("will trigger first_step_only for new setup $sid");
                        return $setup->trigger(first_step_only => 1);
                    }
                    sub {
                        delete $currently_triggering{$sid};
                        delete $datasource_watchers{$ds_id}->{working};
                        $im->debug("finished first_step_only trigger of setup $sid");
                        my $error = shift || $@;
                        if ($error) {
                            if ($error =~ /^DataSource error: /) {
                                delete $setups{$sid};
                                &{$ds_working_sub}($ds_id, $error);
                            }
                            else {
                                # later on a watcher on this setup will have better
                                # error handling and report the setup problems
                            }
                        }
                    };
                }
                
                # when testing, we don't want to have this keep running
                # after all the setups have completed
                if ($deployment eq 'testing' && !($debug && $single_setup)) {
                    my $completed = 0;
                    foreach my $setup (@setups) {
                        $completed++ if $setup->currently_complete;
                    }
                    exit_handler("All the setups are currently complete") if $completed == @setups;
                }
                
                # create a watcher for each setup's datasource to keep it
                # up-to-date
                foreach my $setup (@new_setups) {
                    my $ds = $setup->datasource;
                    $ds->initialize_inmemory; # prior to forking
                    my $ds_id = $ds->id;
                    $datasource_watchers{$ds_id}->{count}++;
                    next if defined $datasource_watchers{$ds_id}->{watcher};
                    
                    $im->debug("will create watcher for ds $ds_id for setup " . $setup->id);
                    
                    my $datasource_update_sub = sub {
                        return if $datasource_watchers{$ds_id}->{working};
                        $datasource_watchers{$ds_id}->{working} = 1;
                        
                        $setup->disconnect;
                        fork_call {
                            $ds->reselect_values_from_db;
                            my $e_before = VRPipe::DataElement->search({ datasource => $ds->id, withdrawn => 0 });
                            $im->debug("will call ds->elements for ds $ds_id");
                            my $e_after_pager = $ds->elements;
                            unless ($e_after_pager) {
                                # we changed to having 0 dataelements
                                foreach my $s (VRPipe::PipelineSetup->search({ datasource => $ds->id })) {
                                    $s->log_event("vrpipe-handler for setups called datasource->elements and got 0 dataelements");
                                }
                                return;
                            }
                            
                            # if we just got new elements, trigger them for each
                            # setup that uses this ds
                            my @triggered_setups = ();
                            my $e_after          = $e_after_pager->total_entries;
                            if ($e_after != $e_before) {
                                foreach my $ds_setup (VRPipe::PipelineSetup->search({ datasource => $ds_id, active => 1 }, { prefetch => ['datasource', 'pipeline'] })) {
                                    # (it's too expensive/risky to set the
                                    #  currently_triggering marker... it should
                                    #  be ok to trigger first step only...)
                                    $ds_setup->log_event("vrpipe-handler for setups called datasource->elements which changed the number of dataelements from $e_before => $e_after, will trigger the first step");
                                    $ds_setup->trigger(first_step_only => 1, prepare_elements => 0);
                                    $im->debug("finished first_step_only trigger for setup " . $ds_setup->id);
                                }
                            }
                            
                            return;
                        }
                        sub {
                            delete $datasource_watchers{$ds_id}->{working};
                            my $error = shift || $@;
                            &{$ds_working_sub}($ds_id, $error);
                        };
                    };
                    
                    my $instance = $ds->_source_instance;
                    my $watcher;
                    if ($instance->can('source_file')) {
                        # update when the source text file changes
                        $watcher = EV::stat $instance->source_file->path->stringify, 0, $datasource_update_sub;
                    }
                    else {
                        # update every 5mins
                        $watcher = EV::timer 0, $datasource_timer_interval, $datasource_update_sub;
                    }
                    
                    $datasource_watchers{$ds_id}->{watcher} = $watcher;
                }
                
                # create a watcher to check the state of each setup, so we
                # can notify user of stalled/ failed/ completed ones
                foreach my $setup (@new_setups) {
                    $setup->initialize_inmemory;
                    my $sid = $setup->id;
                    next if defined $setup_watchers{$sid};
                    
                    $setup_watchers{$sid} = EV::timer int(rand($setup_state_timer_interval)), $setup_state_timer_interval, sub {
                        return if $currently_triggering{$sid};
                        $currently_triggering{$sid} = 1;
                        my $ds_id = $setup->datasource->id;
                        $datasource_watchers{$ds_id}->{working} = 1;
                        
                        $setup->disconnect;
                        fork_call {
                            # we will email the user once when overall state
                            # changes
                            my $mt = VRPipe::MessageTracker->create(subject => "overall state of setup $sid");
                            $setup->reselect_values_from_db;
                            my $num_states = $setup->dataelementstates;
                            
                            if ($setup->currently_complete) {
                                unless ($mt->already_sent("complete with $num_states elements")) {
                                    unless ($num_states == 0) {
                                        $setup->log_event("vrpipe-handler for setups completed the setup with $num_states DataElements");
                                        my $name = $setup->name;
                                        my $long = "\nTo remind yourself about this setup, do:\n\$ vrpipe-status --setup $sid\n\nTo get easy access to the output files, use vrpipe-output. eg:\n\$ vrpipe-output --setup $sid --output_with_input --basename_as_output\n\nIf this setup is now really complete (you won't be adding any more data to the datasource in future), please run:\n\$ vrpipe-setup --setup $sid --deactivate\n";
                                        $im->log("Setup $sid ($name) has completed for $num_states DataElements", email_to => [$setup->user], subject => "Setup $sid has completed", long_msg => $long);
                                    }
                                }
                                
                                return;
                            }
                            
                            # tell user about repeatedly failed subs
                            my $perma_fails = VRPipe::Submission->search({ '_done' => 0, '_failed' => 1, retries => 3, 'stepstate.pipelinesetup' => $sid }, { join => ['stepstate'] });
                            if ($perma_fails) {
                                unless ($mt->already_sent("has some perma fails")) {
                                    $setup->log_event("vrpipe-handler for setups found repeated failures for the setup that need user intervention");
                                    my $name = $setup->name;
                                    my $long = "Investigate the problems by running:\n\$ vrpipe-submissions --setup $sid --failed\n(add --list 1 to limit the amount of output)\n\nOnce the issue has been resolved, give the failed submissions another try by running:\n\$ vrpipe-submissions --setup $sid --failed --start_over --no_report\n(or replace --start_over with --full_reset if your fix would change the command line that needs to be run)\n";
                                    $im->log("Setup $sid ($name) has repeated failures that need user intervention", email_to => [$setup->user], subject => "Setup $sid has problems", long_msg => $long);
                                }
                            }
                            
                            # force a trigger for any apparently stalled
                            # datalementstates
                            $im->debug("looking for stalls");
                            my $ie_pager = $setup->datasource->incomplete_element_states($setup, prepare => 0);
                            my $error_message;
                            if ($ie_pager) {
                                $im->debug("got incomplete_element_states");
                                while (my $dess = $ie_pager->next) {
                                    foreach my $des (@$dess) {
                                        my $de = $des->dataelement;
                                        my $have_subs = VRPipe::Submission->search({ 'stepstate.dataelement' => $de->id, 'stepstate.pipelinesetup' => $sid }, { join => 'stepstate' });
                                        $im->debug("de " . $de->id . " has $have_subs subs");
                                        
                                        if ($have_subs) {
                                            # we have subs so must have parsed
                                            # something so there's no need to
                                            # trigger... except in the case that
                                            # all the subs are complete, in
                                            # which case either we have an
                                            # incomplete stepstate that the
                                            # parse failed on, or we managed to
                                            # complete one stepstate without
                                            # creating a stepstate for the next
                                            # step
                                            my $complete_subs = VRPipe::Submission->search({ 'stepstate.dataelement' => $de->id, 'stepstate.pipelinesetup' => $sid, '_done' => 1 }, { join => 'stepstate' });
                                            next unless $complete_subs == $have_subs;
                                        }
                                        
                                        $im->log("forcing the trigger of dataelement " . $de->id . " (setup $sid) because it seems to be stalled");
                                        my $this_error = $setup->trigger(dataelement => $de);
                                        if ($this_error && !$error_message) {
                                            $error_message = $this_error;
                                        }
                                    }
                                }
                            }
                            $im->debug("after looking for stalls");
                            
                            # make sure that any same_submissions_as stepstates
                            # haven't gotten stuck, which seems to be an issue
                            # (*** bug elsewhere?)
                            my $step_state_pager = VRPipe::StepState->search_paged({ pipelinesetup => $sid, same_submissions_as => { '!=' => undef }, complete => 0 });
                            if ($step_state_pager) {
                                while (my $step_states = $step_state_pager->next) {
                                    foreach my $step_state (@$step_states) {
                                        my $same = $step_state->same_submissions_as;
                                        next unless $same->complete;
                                        my $de = $step_state->dataelement;
                                        $im->log("forcing the trigger of dataelement " . $de->id . " (setup $sid) because its stepstate has the same submissions as one that completed");
                                        my $this_error = $setup->trigger(dataelement => $de);
                                        if ($this_error && !$error_message) {
                                            $error_message = $this_error;
                                        }
                                    }
                                }
                            }
                            
                            unless ($perma_fails) {
                                if ($error_message) {
                                    unless ($mt->already_sent("trigger problem")) {
                                        $setup->log_event("vrpipe-handler for setups hit problems during trigger(): $error_message");
                                        $im->log($error_message, email_to => [$setup->user], email_admin => 1, subject => "Setup $sid has problems");
                                    }
                                }
                                else {
                                    $im->debug("no error - running normally");
                                    $mt->update_message("running normally");
                                }
                            }
                            else {
                                $im->debug("had perma fails, so did not output error");
                            }
                            
                            return;
                        }
                        sub {
                            delete $currently_triggering{$sid};
                            delete $datasource_watchers{$ds_id}->{working};
                            my $err = $@ || return;
                            my $mt = VRPipe::MessageTracker->create(subject => "overall state of setup $sid");
                            unless ($mt->already_sent("unknown problem")) {
                                $setup->log_event("vrpipe-handler for setups encountered an unknown problem: $err");
                                $im->log("There is a problem with setup $sid:\n$err", email_to => [$setup->user], email_admin => 1, subject => "Setup $sid has problems");
                            }
                        };
                    };
                }
            }
            else {
                exit_handler("There are no longer any more setups to handle for farm $farm");
            }
        }
    };
    
    # set up the signals we'll react to
    $SIG{HUP}  = 'IGNORE';
    $SIG{PIPE} = 'IGNORE';
    my $sigterm_watcher = EV::signal 'TERM', sub { exit_handler("SIGTERM received"); };
    my $sigint_watcher  = EV::signal 'INT',  sub { exit_handler("SIGINT received"); };
    my $sigquit_watcher = EV::signal 'QUIT', sub { exit_handler("SIGQUIT received"); };
    
    # run the event loop
    $im->log("The setups handler for farm $farm is now running.");
    EV::run;
    
    $im->log("The setups handler for farm $farm is now exiting!");
    kill_remaining_children();
    exit 0;
}

sub handle_submissions {
    my ($req, $scheduler, $given_sub) = @_;
    $im->log_stderr unless $debug;
    my $req_id                   = $req->id;
    my $time_needed              = $req->time;
    my $end_time                 = (time() + $scheduler->queue_time($req)) - 65;
    my $mins_before_switching    = $time_needed < 600 ? 1 : 5;
    my $seconds_before_switching = $mins_before_switching * 60;
    my $current_req_time         = $req->time;
    
    $im->debug("entered handle_submissions");
    
    my ($sidtosub, $grabbed_sub);
    my $forget_notes_after = $deployment eq 'production' ? 600 : 60;
    unless ($given_sub) {
        # grab a submission from the InMemory queue
        my $sub_id = $im->dequeue($req_id);
        if ($sub_id) {
            $im->debug("grabbed sub $sub_id from the redis queue");
            
            # note that we grabbed this, so that the server doesn't readd the
            # sub to the queue. Set an expire time in case this process dies
            # before finishing the submission
            $grabbed_sub = VRPipe::Submission->get(id => $sub_id);
            $grabbed_sub->note('grabbed', forget_after => $forget_notes_after);
            
            # create a sidtosub
            $sidtosub = VRPipe::SidToSub->create(farm => $farm, req_id => $req->id, sid => $scheduler->get_scheduler_id, aid => $scheduler->get_1based_index, sub_id => $sub_id, assignment_time => DateTime->now);
            $im->debug("created sidtosub " . $sidtosub->id . " for sid " . $scheduler->get_scheduler_id . "[" . $scheduler->get_1based_index . "] and sub $sub_id");
        }
        else {
            return exit_handler("There were no submissions for req $req_id in the queue");
        }
    }
    
    $req->disconnect;
    
    # every so often we'll check on our submission to see how it is doing.
    # if we don't have one, we'll grab one from the redis queue
    my $timer_interval = $deployment eq 'production' ? 60 : 5;
    my ($submission, $job, $job_start_time, $working, $no_subs_found);
    
    my $handled_submissions = 0;
    my $watcher = EV::timer 0, $timer_interval, sub {
        $im->debug("entered timer, working is " . ($working ? 1 : 0));
        return if $working;
        $working = 1;
        
        if ($submission) {
            $im->debug("looking at sub");
            
            eval {
                if ($deployment eq 'testing') {
                    my $still_in_db = VRPipe::Job->search({ id => $submission->job->id });
                    $still_in_db ||= VRPipe::SidToSub->search({ id => $sidtosub->id });
                    unless ($still_in_db) {
                        return exit_handler("Looks like the database was dropped");
                    }
                    
                    # in production we don't want to kill a job part-way through
                    # running it just because the server went down, but in
                    # testing it means the test finished, and we want to clean
                    # up any remaining handlers
                    if (!$debug && !$fs->locked) {
                        return exit_handler("Looks like the $farm server stopped");
                    }
                }
                
                my $close_to_time_limit = (time() - $job_start_time) > ($current_req_time - $seconds_before_switching);
                my $still_locked = $job->locked(by_me => 1);
                
                if (!$still_locked && $job->end_time) {
                    $job->reselect_values_from_db;
                    $submission->reselect_values_from_db;
                    eval { $submission->archive_output; };
                    
                    if ($submission->done) {
                        $submission->stepstate->pipelinesetup->log_event("vrpipe-handler for submissions found that the Submission was done", stepstate => $submission->stepstate->id, dataelement => $submission->stepstate->dataelement->id, submission => $submission->id, job => $job->id);
                    }
                    elsif ($submission->failed) {
                        # Job->run itself would have adjusted $submission's
                        # requirements already if we failed due to running out of
                        # time or memory; we just need to retry it if appropriate
                        $submission->stepstate->pipelinesetup->log_event("vrpipe-handler for submissions found that the Submission is failed (now " . $submission->retries . " retries)", stepstate => $submission->stepstate->id, dataelement => $submission->stepstate->dataelement->id, submission => $submission->id, job => $job->id);
                        $submission->retry if $submission->retries < 3;
                    }
                    if ($sidtosub) {
                        $im->debug("had a sidtosub, will undef it");
                        $submission->forget_note('grabbed');
                        eval {
                            $sidtosub->sub_id(undef);
                            $sidtosub->update;
                            $req->disconnect;
                        };
                    }
                    else {
                        $im->debug("had no sidtosub");
                    }
                    
                    my $signal = $job->_signalled_to_death;
                    if ($signal) {
                        $submission->stepstate->pipelinesetup->log_event("vrpipe-handler for submissions will exit because it received a SIG$signal", stepstate => $submission->stepstate->id, dataelement => $submission->stepstate->dataelement->id, submission => $submission->id, job => $job->id);
                        return exit_handler($submission->id . " failed because we received a SIG$signal");
                    }
                    
                    $im->debug("will undef submission");
                    $submission->unlock;
                    undef $submission;
                }
                elsif (!$still_locked) {
                    $submission->stepstate->pipelinesetup->log_event("vrpipe-handler for submissions will exit because it lost the lock on a job it was monitoring", stepstate => $submission->stepstate->id, dataelement => $submission->stepstate->dataelement->id, submission => $submission->id, job => $job->id);
                    return exit_handler("lost the lock on job of submission " . $submission->id);
                }
                elsif ($close_to_time_limit) {
                    # user's scheduler might kill the submission if it runs too
                    # long in the queue it was initially submitted to; avoid
                    # this by changing queue as necessary
                    $im->debug("sub " . $submission->id . " is close to time limit");
                    $req->disconnect;
                    my $current_queue = $scheduler->determine_queue($submission->requirements);
                    my $transaction   = sub {
                        $submission->extra_time;
                        unless ($given_sub) {
                            $sidtosub->req_id($submission->requirements->id);
                            $sidtosub->update;
                        }
                    };
                    $req->do_transaction($transaction, 'Failed to add extra time to our submission requirements');
                    $current_req_time = $submission->requirements->time;
                    $req->disconnect;
                    my $new_queue = $scheduler->determine_queue($submission->requirements);
                    
                    if ($new_queue ne $current_queue) {
                        $submission->stepstate->pipelinesetup->log_event("vrpipe-handler for submissions is close to the time limit, so switching from queue $current_queue to $new_queue", stepstate => $submission->stepstate->id, dataelement => $submission->stepstate->dataelement->id, submission => $submission->id, job => $job->id);
                        $req->disconnect;
                        $scheduler->switch_queue($scheduler->get_scheduler_id, $new_queue);
                    }
                    
                    # we do not update $req, so that once this $submission has
                    # finished we should think that we've run out of time and kill
                    # ourselves, keeping vrpipe-server's estimation of how many
                    # handlers per req are running nice and accurate
                }
                else {
                    $im->debug("sub " . $submission->id . " job " . $job->id . " hasn't ended yet");
                }
            };
            
            if ($@) {
                # we want to avoid exiting while we're still running a job, so
                # just blindly ignore the problem and hope it goes away...
                $im->log("There was a problem monitoring Submission " . $submission->id . ": $@");
                
                if ($submission->done) {
                    # we encountered some error yet we managed to complete our
                    # work, so just exit
                    return exit_handler("encountered an unusual error yet finished handling submission " . $submission->id);
                }
            }
        }
        unless ($submission) {
            $im->debug("have no sub");
            
            eval {
                if (time() >= $end_time) {
                    return exit_handler("There is not enough time to start working on a new submission");
                }
                if (!$debug && !$fs->locked) {
                    return exit_handler("There is no longer a server for farm $farm");
                }
                
                # if we were given only one Submission to do, run it then exit
                my $sub_id;
                if ($given_sub) {
                    $im->debug("was given a sub");
                    $given_sub->reselect_values_from_db;
                    if ($given_sub->done || $given_sub->failed) {
                        return exit_handler("Handled the given Submission");
                    }
                    else {
                        $sub_id = $given_sub->id;
                    }
                }
                else {
                    my $still_in_db = VRPipe::SidToSub->search({ id => $sidtosub->id });
                    unless ($still_in_db) {
                        return exit_handler("Our SidToSub got deleted");
                    }
                    
                    # try to claim and run the sub_id we got from the redis queue
                    # (and get one from the queue if we don't have one)
                    $im->debug("will check if sid has grabbed a sub yet");
                    $sidtosub->reselect_values_from_db;
                    $sub_id = $sidtosub->sub_id;
                    
                    unless ($sub_id) {
                        # get one from the redis queue
                        $sub_id = $im->dequeue($req_id);
                        if ($sub_id) {
                            $grabbed_sub = VRPipe::Submission->get(id => $sub_id);
                            $grabbed_sub->note('grabbed', forget_after => $forget_notes_after);
                            $sidtosub->sub_id($sub_id);
                            $sidtosub->update;
                        }
                    }
                }
                
                if ($sub_id) {
                    $im->debug("we grabbed a sub, will try to run it");
                    ($submission) = VRPipe::Submission->search({ id => $sub_id });
                    unless ($submission) {
                        $sidtosub->sub_id(undef);
                        $sidtosub->update;
                        $grabbed_sub->forget_note('grabbed');
                        $im->debug("not assigned an existing submission");
                    }
                    else {
                        # we'll try and claim this one to run
                        undef $no_subs_found;
                        my $remaining_time = int($end_time - time());
                        if ($remaining_time < $time_needed) {
                            $sidtosub->delete;
                            
                            # it's possible that we're dealing with a sub
                            # with time requirements close to or matching
                            # the limit of the queue we get submitted to,
                            # which would mean we always exit here and never
                            # actually run it; give it more time in that
                            # case
                            if ($handled_submissions == 0 && $time_needed - $remaining_time < 300) {
                                $submission->extra_time;
                            }
                            
                            return exit_handler("Not enough time to try and run our submission ($remaining_time < $time_needed)");
                        }
                        
                        my $response;
                        ($response, $job) = $submission->claim_and_run(allowed_time => $remaining_time);
                        if ($response == 0) {
                            # there was some problem with this sub and it
                            # just got reset; let's ignore it for now and
                            # deal with it on the next 'loop'
                            undef $submission;
                        }
                        elsif ($response == 2 || $response == 3) {
                            # the job already exited and the sub is
                            # done/failed, or the job is currently running
                            # under another process; in either case
                            # unassign it
                            $sidtosub->sub_id(undef);
                            $sidtosub->update;
                            undef $submission;
                        }
                        elsif ($response == 1) {
                            # we just started running the sub's job
                            $handled_submissions++;
                            my $extra = '';
                            if (!$given_sub && $sidtosub) {
                                $extra = "(sidtosub " . $sidtosub->id . ", scheduler id " . $sidtosub->sid . '[' . $sidtosub->aid . '])';
                            }
                            $submission->stepstate->pipelinesetup->log_event("vrpipe-handler for submissions called claim_and_run() and was successful" . $extra, stepstate => $submission->stepstate->id, dataelement => $submission->stepstate->dataelement->id, submission => $submission->id, job => $submission->job->id);
                            $job_start_time = $job->start_time->epoch;
                        }
                    }
                }
                else {
                    $im->debug("no suitable subs in the redis queue");
                }
            };
            
            if ($@) {
                exit_handler("There was a problem claiming and running a new submission: $@");
            }
            elsif (!defined $submission) {
                # wait for 5 failed attempts in a row to get a submission
                # before exiting
                $no_subs_found++;
                if ($no_subs_found == 5) {
                    exit_handler("No submissions to work on");
                }
            }
        }
        
        $im->debug("disconnecting and setting working to 0");
        $req->disconnect;
        $working = 0;
    };
    
    # run the event loop
    $im->debug("The submissions handler for farm $farm, req " . $req->id . " is now running.");
    EV::run;
    
    if ($grabbed_sub) {
        $grabbed_sub->forget_note('grabbed');
    }
    if ($submission) {
        $submission->unlock;
    }
    
    $im->debug("The submissions handler for farm $farm, req " . $req->id . " is now exiting, having handled $handled_submissions submissions!");
    kill_remaining_children();
    exit 0;
}

sub exit_handler {
    my $msg = shift;
    my $method = $mode eq 'setups' ? 'log' : 'debug';
    $im->$method($msg . ", will gracefully exit $mode handler."); # if $mode eq 'setups'
    EV::unloop;
}

sub kill_remaining_children {
    my $ppt = Proc::ProcessTable->new(cache_ttys => 1);
    my $pgrp;
    foreach my $p (@{ $ppt->table }) {
        if ($p->pid == $$) {
            $pgrp = $p->pgrp;
            last;
        }
    }
    foreach my $p (@{ $ppt->table }) {
        next unless $p->pgrp == $pgrp;
        my $pid = $p->pid;
        next if $pid == $$;
        killfam "KILL", $pid;
    }
}
