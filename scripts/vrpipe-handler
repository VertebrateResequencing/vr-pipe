#!/usr/bin/env perl
use strict;
use warnings;

=head1 AUTHOR

Sendu Bala <sb10@sanger.ac.uk>.

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2012-2015 Genome Research Limited.

This file is part of VRPipe.

VRPipe is free software: you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program. If not, see L<http://www.gnu.org/licenses/>.

=cut

use EV;
use AnyEvent;
use AnyEvent::Util qw(fork_call);
use Parallel::ForkManager;
use Sys::CPU;
use VRPipe::FrontEnd;
use VRPipe::Interface::BackEnd;
use Proc::ProcessTable;
use Proc::Killfam;
use DateTime;
use VRPipe::MessageTracker;

# handle options
my $cmdline = VRPipe::FrontEnd->new(
    description => "Handle the updating of datasources or running submissions while executing on a farm node.",
    opt_spec    => [
        ['One of three modes must be specified, as must --farm.'],
        ['mode|m=s', 'datasources|dataelementstates|submissions - handle datasources, dataelementstates or submissions'],
        ['farm=s',   'Handle stuff being controlled by this farm'],
        [],
        ['In --mode submissions, you must also supply:'],
        ['requirements|r=i', 'a Requirements id, to handle any Submission with these requirements', { persistent_object => 'Requirements' }],
        ['scheduler|s=i',    'a Scheduler id',                                                      { persistent_object => 'Scheduler' }],
        [],
        ['debug', 'turn lots of debugging output on, and allow it to work without a server running'],
        ['datasource=i',       'when --debug is on and you are in --mode datasources, you can make it only look at a given datasource',             { persistent_object => 'DataSource' }],
        ['dataelementstate=i', 'when --debug is on and you are in --mode dataelementstates, you can make it only look at a given dataelementstate', { persistent_object => 'DataElementState' }],
        ['submission=i',       'when --debug is on and you are in --mode submissions, you can make it only look at the given Submission',           { persistent_object => 'Submission' }],
    ]
);

my $max_forks = int(Sys::CPU::cpu_count() / 2);
$max_forks ||= 1;
my $farm = $cmdline->opts('farm') || $cmdline->die_with_error("--farm is required");

# initialize the VRPipe backend
my $deployment = $cmdline->opts('deployment');
my $backend    = VRPipe::Interface::BackEnd->new(deployment => $deployment, farm => $farm);
my $schema     = $backend->schema;
$AnyEvent::Util::MAX_FORKS = $max_forks;
my $debug = $cmdline->opts('debug');
my $im    = VRPipe::Persistent::InMemory->new();

# act on the given mode
my $mode = $cmdline->opts('mode') || $cmdline->die_with_error("--mode must be supplied");
my $fs;
unless ($debug) {
    ($fs) = VRPipe::FarmServer->search({ farm => $farm });
    unless ($fs && $fs->is_alive) {
        $cmdline->die_with_error("There is no farm server running for farm '$farm'");
    }
}
if ($debug || $deployment eq 'testing') {
    $backend->set_verbose_global(1);
}

if ($mode eq 'datasources') {
    my $given_ds = $cmdline->opts('datasource') if $debug;
    handle_datasources($given_ds);
}
elsif ($mode eq 'dataelementstates') {
    my $given_des = $cmdline->opts('dataelementstate') if $debug;
    handle_dataelementstates($given_des);
}
elsif ($mode eq 'submissions') {
    my ($req, $scheduler);
    my $given_sub = $cmdline->opts('submission') if $debug;
    if ($given_sub) {
        $req       = $given_sub->requirements;
        $scheduler = $given_sub->scheduler;
    }
    else {
        $scheduler = $cmdline->opts('scheduler')    || $cmdline->die_with_error("--scheduler must be supplied if not --submission");
        $req       = $cmdline->opts('requirements') || $cmdline->die_with_error("--requirements must be supplied with --submission");
    }
    
    handle_submissions($req, $scheduler, $given_sub);
}
else {
    $cmdline->die_with_error("$mode is an invalid mode");
}

exit 0;

sub handle_datasources {
    $im->log_stderr unless $debug;
    my $single_ds = shift;
    
    # every 30s we'll check for new ds to handle, and also confirm there is
    # still a farmserver up for our farm (and exit if not)
    my (%datasource_watchers, %handled_datasources);
    my $check_timer_interval = $deployment eq 'production' && !$debug ? 30 : 5;
    my $datasource_timer_interval = $deployment eq 'production' ? 300 : 10;
    my $check_watcher;
    my @watchers = ({ 1 => $check_watcher }, \%datasource_watchers);
    $check_watcher = EV::timer 0, $check_timer_interval, sub {
        my @freshly_grabbed_datasources = ();
        eval {
            unless ($debug) { $fs->is_alive || die "no farmserver" }
            if ($single_ds) {
                $single_ds->note('grabbed', forget_after => $datasource_timer_interval);
                @freshly_grabbed_datasources = ($single_ds);
            }
            else {
                # the server has queued datasources that need handling; grab as
                # many as we can cope with and note that we grabbed them so the
                # server doesn't reque them
                my $already_handling = keys %handled_datasources;
                unless ($already_handling == $max_forks) {
                    my $start = $already_handling + 1;
                    for ($start .. $max_forks) {
                        my $ds_id = $im->dequeue('ds_for_handlers.' . $farm);
                        last unless $ds_id;
                        my ($ds) = VRPipe::DataSource->search({ id => $ds_id });
                        redo unless $ds;
                        $ds->note('grabbed', forget_after => $datasource_timer_interval);
                        push(@freshly_grabbed_datasources, $ds);
                    }
                }
            }
        };
        if ($@) {
            if ($@ =~ /no farmserver/) {
                return exit_handler("There is no longer a server for farm $farm", @watchers);
            }
            else {
                return exit_handler("There was a problem accessing the database: $@", @watchers);
            }
        }
        else {
            eval {
                my %all_ds = map { $_->id => $_ } @freshly_grabbed_datasources;
                while (my ($id, $ds) = each %handled_datasources) {
                    $all_ds{$id} = $ds;
                }
                my @all_ds = values %all_ds;
                
                if (@all_ds) {
                    # remove watchers for datasources no longer for setups that
                    # are active
                    while (my ($stored_ds_id, $stored_ds) = each %handled_datasources) {
                        my $active = VRPipe::PipelineSetup->search({ datasource => $stored_ds_id, active => 1, controlling_farm => $farm });
                        
                        if ($active || ($debug && $single_ds)) {
                            $stored_ds->note('grabbed', forget_after => $datasource_timer_interval);
                        }
                        else {
                            delete $datasource_watchers{$stored_ds_id};
                            delete $handled_datasources{$stored_ds_id};
                            $stored_ds->forget_note('grabbed');
                        }
                    }
                    unless (@freshly_grabbed_datasources || keys %handled_datasources) {
                        return exit_handler("There are no longer any more datasources to handle for active setups on farm $farm", @watchers);
                    }
                    
                    # when testing, we don't want to have this keep running
                    # after all the setups associated with our ds have completed
                    if ($deployment eq 'testing' && !($debug && $single_ds)) {
                        my @all_setups;
                        foreach my $ds (@all_ds) {
                            push(@all_setups, VRPipe::PipelineSetup->search({ datasource => $ds, active => 1, controlling_farm => $farm }));
                        }
                        
                        my $completed = 0;
                        foreach my $setup (@all_setups) {
                            $completed++ if $setup->currently_complete;
                        }
                        return exit_handler("All the datasources are for currently complete setups", @watchers) if $completed == @all_setups;
                    }
                    
                    # create a watcher for each new datasource to keep it
                    # up-to-date
                    my $ds_working_sub = sub {
                        my ($ds_id, $err) = @_;
                        $err =~ s/^DataSource error: // if $err;
                        
                        foreach my $s (VRPipe::PipelineSetup->search({ datasource => $ds_id })) {
                            my $sid = $s->id;
                            my $mt = VRPipe::MessageTracker->create(subject => "datasource $ds_id state message for setup $sid");
                            
                            if ($err) {
                                # email user about the error once per setup
                                unless ($mt->already_sent("not working")) {
                                    $s->log_event("vrpipe-handler for datasources found that DataSource $ds_id has problems: $err");
                                    $im->log("There is a problem with datasource $ds_id for setup $sid", email_to => [$s->user], subject => "Setup $sid has problems with its DataSource", long_msg => $err);
                                }
                            }
                            else {
                                $mt->update_message("working fine");
                            }
                        }
                    };
                    
                    foreach my $ds (@freshly_grabbed_datasources) {
                        my $ds_id = $ds->id;
                        next if exists $handled_datasources{$ds_id};
                        $handled_datasources{$ds_id} = $ds;
                        next if defined $datasource_watchers{$ds_id};
                        
                        $ds->initialize_inmemory; # prior to forking
                        $im->debug("will create watcher for ds $ds_id");
                        
                        my $datasource_update_sub = sub {
                            return if $datasource_watchers{$ds_id}->{working};
                            $datasource_watchers{$ds_id}->{working} = 1;
                            
                            $ds->disconnect;
                            fork_call {
                                $ds->reselect_values_from_db;
                                $im->debug("will call ds->elements for ds $ds_id");
                                # the elements call will queue up states to be
                                # triggered; vrpipe-server will take care of
                                # those
                                $ds->debug($debug) if $debug;
                                my $e_after_pager = $ds->elements;
                                unless ($e_after_pager) {
                                    # we changed to having 0 dataelements
                                    foreach my $s (VRPipe::PipelineSetup->search({ datasource => $ds->id })) {
                                        $s->log_event("vrpipe-handler for setups called datasource->elements and got 0 dataelements");
                                    }
                                }
                                
                                return;
                            }
                            sub {
                                delete $datasource_watchers{$ds_id}->{working};
                                my $error = shift || $@;
                                &{$ds_working_sub}($ds_id, $error);
                            };
                        };
                        
                        my $instance = $ds->_source_instance;
                        my $watcher;
                        if ($instance->can('source_file')) {
                            # update when the source text file changes
                            $watcher = EV::stat $instance->source_file->path->stringify, 0, $datasource_update_sub;
                        }
                        else {
                            # update every 5mins
                            $watcher = EV::timer 0, $datasource_timer_interval, $datasource_update_sub;
                        }
                        
                        $datasource_watchers{$ds_id}->{watcher} = $watcher;
                        $im->log("A datasource handler for farm $farm is now watching datasource $ds_id");
                    }
                }
                else {
                    return exit_handler("There are no longer any more setups to handle for farm $farm", @watchers);
                }
            };
            if ($@) {
                return exit_handler("Unexpected error in setups handler: $@", @watchers);
            }
        }
    };
    
    # set up the signals we'll react to
    $SIG{HUP}  = 'IGNORE';
    $SIG{PIPE} = 'IGNORE';
    my $sigterm_watcher = EV::signal 'TERM', sub { exit_handler("SIGTERM received", @watchers); };
    my $sigint_watcher  = EV::signal 'INT',  sub { exit_handler("SIGINT received",  @watchers); };
    my $sigquit_watcher = EV::signal 'QUIT', sub { exit_handler("SIGQUIT received", @watchers); };
    
    # run the event loop
    my $num_ds = $im->queue('ds_for_handlers.' . $farm);
    $im->log("A datasource handler for farm $farm is now running; currently there are $num_ds datasources in the queue.");
    EV::run;
    
    if ($im->datastore_ok) {
        foreach my $grabbed_ds (values %handled_datasources) {
            $grabbed_ds->forget_note('grabbed');
        }
    }
    $im->log("A datasource handler for farm $farm is now exiting!");
    
    kill_remaining_children();
    exit 0;
}

sub handle_dataelementstates {
    $im->log_stderr unless $debug;
    my $single_des = shift;
    
    my @triggers_queued = $im->queue('trigger');
    my $total           = scalar(@triggers_queued);
    
    $im->log("A dataelementstates handler for farm $farm is now running; right now there are $total dataelements to be triggered.");
    my $inter_message_time = 86400;
    
    my $trigger_sub = sub {
        my $des   = shift;
        my $setup = $des->pipelinesetup;
        warn "will trigger setup ", $setup->id, ", de ", $des->dataelement->id, "\n" if $debug;
        my $err = $setup->trigger(dataelement => $des->dataelement, debug => $debug);
        $im->log("A dataelementstates handler triggered setup " . $setup->id . ", dataelement " . $des->dataelement->id . '.');
        
        my $sid     = $setup->id;
        my $step    = $des->completed_steps + 1;
        my $subject = "state of setup $sid at step $step (triggering)";
        my $mt      = VRPipe::MessageTracker->create(subject => $subject);
        
        if ($err) {
            unless ($mt->already_sent("trigger problem")) {
                # since the message could be flipping back and forth between
                # problem and normal for different dataelements of this setup,
                # we'll only log the problem at most once per day
                if ($im->lock($subject, unlock_after => $inter_message_time)) {
                    $setup->log_event("vrpipe-handler for dataelementstates hit problems during trigger() of an element trying to go through step $step : $err");
                    $im->log($err, email_to => [$setup->user], email_admin => 1, subject => "Setup $sid has problems getting to step $step");
                }
            }
        }
        else {
            $mt->update_message("running normally");
        }
    };
    
    my $triggered = 0;
    if ($single_des) {
        &$trigger_sub($single_des);
        $triggered = 1;
    }
    else {
        # we'll only trigger des that belong to active setups that our farm is
        # handling
        my %setup_ids;
        foreach my $setup (VRPipe::PipelineSetup->search({ controlling_farm => $farm, active => 1 })) {
            $setup_ids{ $setup->id } = 1;
        }
        
        # in parallel we'll have loops that dequeue and trigger des until there
        # are no more to trigger, then we exit after 30s of nothing to trigger
        my $fm = Parallel::ForkManager->new($max_forks);
        $fm->run_on_finish(
            sub {
                my ($pid, $trigs) = @_;
                $triggered += $trigs if $trigs;
            }
        );
        for (1 .. $max_forks) {
            $fm->start and next;
            
            my $time_of_last_trigger = time();
            my $trigs                = 0;
            while (1) {
                while (my $to_trigger = $im->dequeue('trigger')) {
                    my ($setup_id, $de_id) = split(/:/, $to_trigger);
                    warn "dequeued setup $setup_id, dataelement $de_id\n" if $debug;
                    if (exists $setup_ids{$setup_id}) {
                        my ($des) = VRPipe::DataElementState->search({ pipelinesetup => $setup_id, dataelement => $de_id });
                        if ($des) {
                            # trigger this des
                            &$trigger_sub($des);
                            $trigs++;
                            $time_of_last_trigger = time();
                        }
                        # else we won't requeue or do anything
                    }
                    else {
                        # requeue it for someone else to deal with
                        $im->enqueue('trigger', $to_trigger);
                        warn "requeued setup $setup_id, dataelement $de_id\n" if $debug;
                    }
                }
                
                last if time() > $time_of_last_trigger + 30;
                if ($fs) {
                    last unless $fs->is_alive;
                }
                sleep(1);
            }
            
            $fm->finish($trigs);
        }
        $fm->wait_all_children;
    }
    
    $im->log("A dataelementstates handler for farm $farm is now exiting, having triggered $triggered dataelements");
    exit 0;
}

sub handle_submissions {
    my ($req, $scheduler, $given_sub) = @_;
    $im->log_stderr unless $debug;
    my $req_id                   = $req->id;
    my $time_needed              = $req->time;
    my $end_time                 = (time() + $scheduler->queue_time($req)) - 65;
    my $mins_before_switching    = $time_needed < 600 ? 1 : 5;
    my $seconds_before_switching = $mins_before_switching * 60;
    my $current_req_time         = $req->time;
    
    $im->debug("entered handle_submissions");
    
    my $grabbed_sub;
    my $forget_notes_after = $deployment eq 'production' ? 600 : 60;
    
    if ($given_sub) {
        $grabbed_sub = $given_sub;
        $grabbed_sub->note('grabbed', forget_after => $forget_notes_after);
    }
    else {
        # grab a submission from the InMemory queue
        my $sub_id;
        while (!$sub_id) {
            $sub_id = $im->dequeue($req_id);
            if ($sub_id) {
                $im->debug("grabbed sub $sub_id from the redis queue");
                
                # note that we grabbed this, so that the server doesn't readd the
                # sub to the queue. Set an expire time in case this process dies
                # before starting the submission
                $grabbed_sub = VRPipe::Submission->get(id => $sub_id);
                $grabbed_sub->note('grabbed', forget_after => $forget_notes_after);
            }
            elsif ($req->noted('generating_subs')) {
                sleep(6);
            }
            else {
                return exit_handler("There were no submissions for req $req_id in the queue");
            }
        }
    }
    
    $req->disconnect;
    
    # every so often we'll check on our submission to see how it is doing.
    # if we don't have one, we'll grab one from the redis queue
    my $timer_interval = $deployment eq 'production' ? 60 : 5;
    my ($submission, $job, $job_start_time, $working);
    
    my $handled_submissions = 0;
    my $watcher;
    my @watchers = ({ 1 => $watcher });
    $watcher = EV::timer 0, $timer_interval, sub {
        return if $working;
        $working = 1;
        
        if ($submission) {
            eval {
                $im->debug("looking at sub");
                
                if ($deployment eq 'testing') {
                    my $still_in_db = VRPipe::Job->search({ id => $submission->job->id });
                    unless ($still_in_db) {
                        return exit_handler("Looks like the database was dropped", @watchers);
                    }
                    
                    # in production we don't want to kill a job part-way through
                    # running it just because the server went down, but in
                    # testing it means the test finished, and we want to clean
                    # up any remaining handlers
                    if (!$debug && !$fs->is_alive) {
                        return exit_handler("Looks like the $farm server stopped", @watchers);
                    }
                }
                
                # the submission may have been started over, in which case it
                # no longer exists in db; we'll just give up in this case
                my $still_in_db = VRPipe::Submission->search({ id => $submission->id });
                unless ($still_in_db) {
                    $job->kill_job($submission, 1);
                    return exit_handler("Looks like submission " . $submission->id . " no longer exists", @watchers);
                }
                
                my $close_to_time_limit = (time() - $job_start_time) > ($current_req_time - $seconds_before_switching);
                my $still_running = $job->cmd_running;
                
                if ($job->end_time) {
                    $submission->reselect_values_from_db;
                    eval { $submission->archive_output; };
                    my $ss      = $submission->stepstate;
                    my $ps      = $ss->pipelinesetup;
                    my $sid     = $ps->id;
                    my $step    = $ss->stepmember->step_number;
                    my $subject = "state of setup $sid at step $step (submissions)";
                    my $mt      = VRPipe::MessageTracker->create(subject => $subject);
                    
                    if ($submission->done) {
                        $ps->log_event("vrpipe-handler for submissions found that the Submission was done", stepstate => $ss->id, dataelement => $ss->dataelement->id, submission => $submission->id, job => $job->id);
                        $mt->update_message("running normally");
                    }
                    elsif ($submission->failed) {
                        # Job->run itself would have adjusted $submission's
                        # requirements already if we failed due to running out
                        # of time or memory; we just need to retry it if
                        # appropriate
                        $ps->log_event("vrpipe-handler for submissions found that the Submission is failed (now " . $submission->retries . " retries)", stepstate => $ss->id, dataelement => $ss->dataelement->id, submission => $submission->id, job => $job->id);
                        
                        if ($submission->retries < 3) {
                            $submission->retry;
                        }
                        else {
                            unless ($mt->already_sent("submission problem")) {
                                # since the message could be flipping back and
                                # forth between a fail for some subs and success
                                # for others, we'll only log the problem at most
                                # once per day
                                if ($im->lock($subject, unlock_after => 86400)) {
                                    my $name = $ps->name;
                                    my $long = "Investigate the problems by running:\n\$ vrpipe-submissions --setup $sid --step $step --failed\n(add --list 1 to limit the amount of output)\n\nOnce the issue has been resolved, give the failed submissions another try by running:\n\$ vrpipe-submissions --setup $sid --step $step --failed --start_over\n(or replace --start_over with --full_reset if your fix would change the command line that needs to be run)\n";
                                    $im->log("Setup $sid ($name) has repeated failures at step $step that need user intervention", email_to => [$ps->user], subject => "Setup $sid has problems at step $step", long_msg => $long);
                                }
                            }
                        }
                    }
                    
                    my $signal = $job->_signalled_to_death;
                    if ($signal) {
                        $ss->log_event("vrpipe-handler for submissions will exit because it received a SIG$signal", stepstate => $ss->id, dataelement => $ss->dataelement->id, submission => $submission->id, job => $job->id);
                        return exit_handler($submission->id . " failed because we received a SIG$signal", @watchers);
                    }
                    
                    $im->debug("will undef submission");
                    undef $submission;
                    undef $job;
                }
                elsif (!$still_running) {
                    $submission->stepstate->pipelinesetup->log_event("vrpipe-handler for submissions will exit because the job it was working on is mysteriously no longer running", stepstate => $submission->stepstate->id, dataelement => $submission->stepstate->dataelement->id, submission => $submission->id, job => $job->id);
                    return exit_handler("job " . $job->id . " stopped running in an abnormal way ", @watchers);
                }
                elsif ($close_to_time_limit) {
                    # user's scheduler might kill the submission if it runs too
                    # long in the queue it was initially submitted to; avoid
                    # this by changing queue as necessary
                    $im->debug("sub " . $submission->id . " is close to time limit");
                    $req->disconnect;
                    my $current_queue = $scheduler->determine_queue($submission->requirements);
                    my $transaction   = sub {
                        $submission->extra_time;
                    };
                    $req->do_transaction($transaction, 'Failed to add extra time to our submission requirements');
                    $current_req_time = $submission->requirements->time;
                    $req->disconnect;
                    my $new_queue = $scheduler->determine_queue($submission->requirements);
                    
                    if ($new_queue ne $current_queue) {
                        $submission->stepstate->pipelinesetup->log_event("vrpipe-handler for submissions is close to the time limit, so switching from queue $current_queue to $new_queue", stepstate => $submission->stepstate->id, dataelement => $submission->stepstate->dataelement->id, submission => $submission->id, job => $job->id);
                        $req->disconnect;
                        $scheduler->switch_queue($scheduler->get_scheduler_id, $new_queue);
                    }
                    
                    # we do not update $req, so that once this $submission has
                    # finished we should think that we've run out of time and
                    # kill ourselves, keeping vrpipe-server's estimation of how
                    # many handlers per req are running nice and accurate
                }
                else {
                    $im->debug("sub " . $submission->id . " job " . $job->id . " hasn't ended yet");
                }
            };
            
            if ($@) {
                # even though the job might still be running ok, we can't risk
                # keeping this process alive forever while it's stuck due to
                # this unknown error
                return exit_handler("There was a problem monitoring Submission " . $submission->id . ": $@", @watchers);
            }
        }
        unless ($submission) {
            eval {
                $im->debug("have no sub");
                
                if (time() >= $end_time) {
                    return exit_handler("There is not enough time to start working on a new submission", @watchers);
                }
                if (!$debug && !$fs->is_alive) {
                    return exit_handler("There is no longer a server for farm $farm", @watchers);
                }
                
                # sort out a sub to work on
                if ($given_sub) {
                    # if we were given only one Submission to do, run it then exit
                    $im->debug("was given a sub");
                    $given_sub->reselect_values_from_db;
                    if ($given_sub->done || $given_sub->failed) {
                        return exit_handler("Handled the given Submission", @watchers);
                    }
                }
                elsif (!$grabbed_sub) {
                    # try to get another sub from the queue
                    my $sub_id;
                    while (!$sub_id) {
                        $sub_id = $im->dequeue($req_id);
                        if ($sub_id) {
                            $im->debug("grabbed sub $sub_id from the redis queue");
                            $grabbed_sub = VRPipe::Submission->get(id => $sub_id);
                            $grabbed_sub->note('grabbed', forget_after => $forget_notes_after);
                        }
                        elsif ($req->noted('generating_subs')) {
                            sleep(6);
                        }
                        else {
                            return exit_handler("There were no submissions for req $req_id in the queue", @watchers);
                        }
                    }
                }
                
                my $sub_id = $grabbed_sub->id;
                $im->debug("we grabbed a sub, will try to run it");
                ($submission) = VRPipe::Submission->search({ id => $sub_id });
                unless ($submission) {
                    $grabbed_sub->forget_note('grabbed');
                    undef $grabbed_sub;
                    $im->debug("not assigned an existing submission");
                }
                else {
                    # we'll try and claim this one to run
                    my $remaining_time = int($end_time - time());
                    if ($remaining_time < $time_needed) {
                        # it's possible that we're dealing with a sub
                        # with time requirements close to or matching
                        # the limit of the queue we get submitted to,
                        # which would mean we always exit here and never
                        # actually run it; give it more time in that
                        # case
                        if ($handled_submissions == 0 && $time_needed - $remaining_time < 300) {
                            $submission->extra_time;
                        }
                        
                        $grabbed_sub->forget_note('grabbed');
                        return exit_handler("Not enough time to try and run our submission ($remaining_time < $time_needed)", @watchers);
                    }
                    
                    my $response;
                    ($response, $job) = $submission->claim_and_run(allowed_time => $remaining_time);
                    if ($response == 0) {
                        # there was some problem with this sub and it
                        # just got reset; let's ignore it for now and
                        # deal with it on the next 'loop'
                        undef $submission;
                    }
                    elsif ($response == 2 || $response == 3) {
                        # the job already exited and the sub is
                        # done/failed, or the job is currently running
                        # under another process; in either case
                        # unassign it
                        undef $submission;
                    }
                    elsif ($response == 1) {
                        # we just started running the sub's job
                        $handled_submissions++;
                        $submission->stepstate->pipelinesetup->log_event("vrpipe-handler for submissions called claim_and_run() and was successful", stepstate => $submission->stepstate->id, dataelement => $submission->stepstate->dataelement->id, submission => $submission->id, job => $submission->job->id);
                        $job_start_time = $job->start_time->epoch;
                    }
                    
                    $grabbed_sub->forget_note('grabbed');
                    undef $grabbed_sub;
                }
            };
            
            if ($@) {
                if ($deployment eq 'testing' && $@ =~ /Could not connect to Redis server/) {
                    return exit_handler("There was a problem claiming and running a new submission; it looks like the testing server was shut down", @watchers);
                }
                return exit_handler("There was a problem claiming and running a new submission: $@", @watchers);
            }
        }
        
        $req->disconnect;
        $working = 0;
    };
    
    # run the event loop
    $im->log("The submissions handler for farm $farm, req " . $req->id . " is now running.");
    EV::run;
    
    if ($im->datastore_ok) {
        if ($grabbed_sub) {
            $grabbed_sub->forget_note('grabbed');
        }
        if ($submission) {
            $submission->unlock;
        }
        $im->log("The submissions handler for farm $farm, req " . $req->id . " is now exiting, having handled $handled_submissions submissions!");
    }
    
    kill_remaining_children();
    exit 0;
}

sub exit_handler {
    my $msg = shift;
    my $method = $mode eq 'setups' ? 'log' : 'debug';
    $im->$method($msg . ", will gracefully exit $mode handler.");
    
    foreach my $watcher_hash_ref (@_) {
        my @keys = keys %$watcher_hash_ref;
        foreach my $key (@keys) {
            delete $watcher_hash_ref->{$key};
        }
    }
    
    EV::unloop;
}

sub kill_remaining_children {
    my $ppt = Proc::ProcessTable->new(cache_ttys => 1);
    my $pgrp;
    foreach my $p (@{ $ppt->table }) {
        if ($p->pid == $$) {
            $pgrp = $p->pgrp;
            last;
        }
    }
    foreach my $p (@{ $ppt->table }) {
        next unless $p->pgrp == $pgrp;
        my $pid = $p->pid;
        next if $pid == $$;
        killfam "KILL", $pid;
    }
}
