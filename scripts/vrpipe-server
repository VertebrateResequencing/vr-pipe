#!/usr/bin/env perl
use strict;
use warnings;

=head1 AUTHOR

Sendu Bala <sb10@sanger.ac.uk>.

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2012 Genome Research Limited.

This file is part of VRPipe.

VRPipe is free software: you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program. If not, see L<http://www.gnu.org/licenses/>.

=cut

use EV;
use AnyEvent;
use AnyEvent::Util qw(fork_call);
use VRPipe::Interface::CmdLine;
use VRPipe::Interface::BackEnd;
use VRPipe::LocalScheduler;
use Sys::CPU;
use POSIX qw(floor);

# handle options
my $cmdline = VRPipe::Interface::CmdLine->new(
    description => "Control the VRPipe server, which provides the web and cmdline interfaces, the local scheduler, and keeps the pipeline system itself running.",
    extra_args  => 'start|stop|restart|status',
    opt_spec    => [
        ['foreground|f',          'Do not daemonize - the server will run in the foreground, logging to STDERR'],
        ['farm=s',                'Discover and dispatch submissions to the job scheduler identified by the supplied name (only 1 server can dispatch to each farm)'],
        ['max_submissions|m=i',   'The maximum number of submissions to dispatch to the farm when in --farm mode (default is unlimited)'],
        ['only_specified_setups', 'In --farm mode, normally any PipelineSetups that have no farm configured will be run on a random farm, so potentially via this server; turning this option on means this server will only handle setups configured for this farm']
    ]
);

my $backend;
my $deployment            = $cmdline->opts('deployment');
my $foreground            = $cmdline->opts('foreground');
my $farm                  = $cmdline->opts('farm');
my $max_subs              = $cmdline->opts('max_submissions');
my $only_specified_setups = $cmdline->opts('only_specified_setups') || 0;

my $command = shift;
unless ($command) {
    $cmdline->error("a command is required");
    $cmdline->help;
}

# act on the given command
my $status = $cmdline->check_server(1);
my (undef, $port, $url) = @{ $cmdline->_ua_port_baseurl };
my $exit = 0;
if ($command eq 'status') {
    if ($status == 1) {
        $cmdline->output("VRPipe $deployment server is running at $url");
    }
    elsif ($status == 0) {
        $cmdline->output("VRPipe $deployment server is not running");
    }
    elsif ($status == -1) {
        $cmdline->output("A server is listening on port $port, but is not responding like our own VRPipe $deployment server would");
    }
}
elsif ($command eq 'stop') {
    my $stopped = stop();
    $exit = !$stopped;
}
elsif ($command eq 'start') {
    my $started = start();
    $exit = !$started;
}
elsif ($command eq 'restart') {
    $cmdline->output("Restarting VRPipe $deployment server...");
    my $stopped = stop();
    my $started = 0;
    if ($stopped) {
        my $started = start();
    }
    $exit = !$started;
}
else {
    $cmdline->die_with_error("$command is an invalid command");
}

exit $exit;

sub stop {
    if ($status == 1) {
        my $response = $cmdline->server_get('/stop');
        if ($response eq 'Stopping server') {
            # the server responded that it would stop; give it up to 5 seconds
            # to actually do that
            my $seconds = 5;
            while ($seconds--) {
                $status = $cmdline->check_server(1);
                last if $status == 0;
                sleep(1);
            }
            
            if ($status == 0) {
                $cmdline->output("VRPipe $deployment server was stopped");
                return 1;
            }
            else {
                $cmdline->output("VRPipe $deployment server claimed it would stop, but it still seems to be running");
                return 0;
            }
        }
        else {
            $cmdline->output("Failed to stop VRPipe $deployment server (it responded: '$response')");
            return 0;
        }
    }
    elsif ($status == 0) {
        $cmdline->output("VRPipe $deployment server was not running");
        return 1;
    }
    elsif ($status == -1) {
        $cmdline->output("Will not attempt to stop the VRPipe $deployment server listening on port $port, since it does not seem to be ours");
        return 0;
    }
}

sub start {
    if ($status == 1) {
        $cmdline->output("VRPipe $deployment server is already running");
        return 1;
    }
    elsif ($status == 0) {
        $cmdline->output("Will start VRPipe $deployment server at $url");
        start_server();
    }
    elsif ($status == -1) {
        $cmdline->output("Will not attempt to start the VRPipe $deployment server, since another incompatible server is already listening on port $port");
        return 0;
    }
}

sub start_server {
    # initialize the VRPipe backend
    $backend = VRPipe::Interface::BackEnd->new(deployment => $deployment);
    
    # daemonize unless we're not supposed to
    $backend->daemonize unless $foreground;
    
    $AnyEvent::Util::MAX_FORKS = Sys::CPU::cpu_count();
    my $timer_interval = $deployment eq 'production' ? 30 : 5;
    
    my $watcher_error_sub = sub {
        my $err = $@ || return;
        
        # when testing, we likely start the server and call some database-
        # requiring method before the VRPipe database has been created,
        # so we make a nicer error message
        if (ref($err)) {
            $err = "$err"; # try and stringify it
        }
        my $email_admin = 1;
        if ($err =~ /no such table/) {
            $err         = 'VRPipe database not created yet, cannot do all functions';
            $email_admin = 0;
        }
        $backend->log($err, email_admin => $email_admin);
    };
    
    # set up the timer for the local scheduler to process its queue. (for timers
    # we use periodic instead of timer because timer seems to have some bug
    # where on the first invocation it happens twice at ~the same time, which
    # can be terrible for us. periodic (usually) does not)
    my $ls = VRPipe::LocalScheduler->new;
    my $ls_watcher = EV::periodic_ns 0, $timer_interval, 0, sub {
        # we want to run process_queue every x seconds, but it may take
        # longer than x seconds to run and we don't want to wait, so we do
        # our own async fork (in order to call something that in turn will
        # do further async forks...). It doesn't seem to matter that our
        # children (presumably) have all our watchers running.
        fork_call { $ls->process_queue; return; } $watcher_error_sub;
    };
    
    # automatically start the local scheduler if we're supposed to be using the
    # local scheduler
    if ($backend->scheduler eq 'local') {
        $ls_watcher->start;
    }
    
    # setup the submission management system if we're supposed to
    my ($farm_server, $farm_watcher, $handler_path, $scheduler);
    if ($farm) {
        # every 30s we'll update which PipelineSetups we'll handle
        $farm_watcher = EV::periodic 0, $timer_interval, 0, sub {
            unless ($farm_server) {
                # ideally we only want to be in this if ($farm) section if we
                # have managed to register_farm_server(), but we can only do
                # that once the database is ready, which won't be the case
                # whilst testing. So we use our timer to keep trying to get the
                # farm_server whilst it fails due to database issues, but cancel
                # the timer if we fail because another server is handling this
                # farm
                eval { $farm_server = $backend->register_farm_server($farm, only_ours => $only_specified_setups) };
                if ($@) {
                    &{$watcher_error_sub};
                }
                elsif ($farm_server) {
                    # our database must be ready now, so load all Pipeline and
                    # Step .pm modules into db if we haven't already
                    $backend->install_pipelines_and_steps unless $deployment eq 'testing';
                    $backend->log("Submission management started for farm $farm");
                    $handler_path = $cmdline->vrpipe_script_command('vrpipe-handler', $deployment);
                    $scheduler = VRPipe::Scheduler->get();
                }
                else {
                    $backend->log("Could not start submission management for farm $farm because some other server on a different machine is doing that");
                    undef $farm_server;
                }
            }
            else {
                fork_call {
                    # check we're still valid
                    die "no longer in db\n" unless $farm_server->alive;
                    $farm_server->stop_beating; # parent process is beating
                    
                    # claim our setups
                    my @setups = $farm_server->claim_setups;
                    
                    if (@setups) {
                        # make sure we have a setups handler running for our
                        # farm
                        $scheduler->ensure_running(
                            cmd          => "$handler_path --mode setups --farm $farm",
                            requirements => VRPipe::Requirements->create(memory => 500, time => 3600),
                            backend      => $backend
                        );
                        
                        # make sure we have sufficient submission handlers
                        # running...
                        
                        # get the count of requirements
                        my $sched_id = $scheduler->id;
                        my $req_counts = [VRPipe::Submission->search_rs({ -or => [-and => ['_failed' => 1, retries => { '<' => 3 }], '_failed' => 0], '_done' => { '!=' => 1 }, scheduler => $sched_id, 'pipelinesetup.controlling_farm' => $farm, 'pipelinesetup.active' => 1 }, { join => { stepstate => 'pipelinesetup' }, select => ['requirements', { count => 'requirements' }], group_by => 'requirements' })->cursor->all];
                        
                        # scale the counts according to $max_subs
                        #*** and eventually, we should have a priority system
                        #    where a particular setup can have higher priority
                        #    than others...
                        if ($max_subs) {
                            my $total_count = 0;
                            foreach my $cols (@$req_counts) {
                                $total_count += $cols->[1];
                            }
                            
                            if ($total_count > $max_subs) {
                                my $reducer = $max_subs / $total_count;
                                foreach my $cols (@$req_counts) {
                                    my (undef, $count) = @$cols;
                                    $total_count += $count;
                                    $cols->[1] = floor($cols->[1] * $reducer);
                                }
                            }
                        }
                        
                        # submit the submission handlers
                        foreach my $cols (@$req_counts) {
                            my ($req_id, $count) = @$cols;
                            $scheduler->ensure_running(
                                cmd                         => "$handler_path --mode submissions --farm $farm -r $req_id -s $sched_id",
                                count                       => $count,
                                requirements                => VRPipe::Requirements->get(id => $req_id),
                                backend                     => $backend,
                                append_runner_option_to_cmd => 1
                            );
                        }
                    }
                    
                    return;
                }
                sub {
                    my $err = $@;
                    if ($err) {
                        # perhaps another process decided our $farm_server was
                        # no longer alive and it has been deleted from the db?
                        # let's still keep the farmserver watcher alive so we
                        # will try and re-register as a farmserver - necessary
                        # when running a bunch of tests where the database keeps
                        # getting dropped and recreated while the server is
                        # running
                        if ($err =~ /no longer in db/) {
                            $backend->log("Could not continue submission management for farm $farm because our entry was removed from the FarmServer tracking table.", email_admin => 1);
                            $farm_server->end_it_all;
                            undef $farm_server;
                        }
                        &{$watcher_error_sub};
                    }
                };
            }
        };
    }
    
    # set up the http page requests we'll respond to
    $backend->register_psgi_pages(
        '/' => sub {
            $backend->psgi_text_response(200, 'html', "<html><body><h1>VRPipe Homepage</h1>" . q[<p>Complete web interface to VRPipe coming soon; currently you can just look at the <a href="/status?brief=1&amp;incomplete=1">status</a> page (like the vrpipe-status command line script).</p>] . "</body></html>", shift);
        },
        '/status'            => sub { $backend->psgi_nonblocking_xml_response(\&status,          shift); },
        '/local_scheduler'   => sub { $backend->psgi_nonblocking_xml_response(\&local_scheduler, shift, $ls_watcher); },
        '/continuation_test' => sub { $backend->psgi_continuation_response(\&continuation_test,  shift); },
        '/dsn' => sub {
            $backend->psgi_text_response(200, 'plain', $backend->dsn, shift);
        },
        '/stop' => sub {
            shutdown_server("Received the stop command");
            $backend->psgi_text_response(200, 'plain', 'Stopping server', shift);
        }
    );
    
    # set up the signals we'll react to
    $SIG{HUP}  = 'IGNORE';
    $SIG{PIPE} = 'IGNORE';
    my $sigterm_watcher = EV::signal 'TERM', sub { shutdown_server("SIGTERM received"); };
    my $sigint_watcher  = EV::signal 'INT',  sub { shutdown_server("SIGINT received"); };
    my $sigquit_watcher = EV::signal 'QUIT', sub { shutdown_server("SIGQUIT received"); };
    
    # run the event loop
    $backend->log("The $deployment server at $url for VRPipe database " . $backend->dsn . " has started (pid $$).", email_admin => 1, subject => 'The VRPipe Server is alive!');
    EV::run;
    
    $backend->log("The $deployment server at $url for VRPipe database " . $backend->dsn . " is exiting!", email_admin => 1, subject => 'The VRPipe Server is dead!');
    exit 0;
}

sub shutdown_server {
    my $msg = shift;
    $backend->log($msg . ", will gracefully shut down server.");
    EV::unloop;
}

# "page" subs
sub status {
    my $req = shift;
    
    my $opts = $backend->req_to_opts($req, ['setup!PipelineSetup']);
    $opts->{'_multiple_setups'} = 1;
    my $list            = $opts->{list};
    my $incomplete_only = $opts->{incomplete};
    my $brief           = $opts->{brief};
    my $defunct_only    = $opts->{defunct};
    if ($defunct_only) {
        undef $list;
        undef $incomplete_only;
        undef $brief;
        $opts->{deactivated} = 1;
    }
    
    my $xml = '<title>Current status of PipelineSetups</title>';
    
    # $xml .= '<options><bool></bool></options>';
    
    my @setups = $backend->get_pipelinesetups($opts);
    if (@setups) {
        my @objects;
        foreach my $setup (@setups) {
            my $object;
            foreach my $attr (qw(id name user active)) {
                $object .= $backend->xml_tag('attribute', $setup->$attr(), qq[name="$attr"]);
            }
            
            if ($list) {
                push(@objects, $object);
                next;
            }
            
            my $datasource = $setup->datasource;
            my $num_elements;
            my $incomplete_pager;
            my $ps_id = $setup->id;
            eval {
                $num_elements = VRPipe::DataElementState->search({ pipelinesetup => $setup->id, 'dataelement.datasource' => $datasource->id, 'dataelement.withdrawn' => 0 }, { join => 'dataelement' });
                $incomplete_pager = $datasource->incomplete_element_states($setup, prepare => 0);
            };
            my $ds_error = $@;
            if ($ds_error || !$incomplete_pager) {
                $ds_error ||= 'Could not create an incomplete_element_states pager for setup ' . $setup->id;
                if ($defunct_only) {
                    #*** due to prepare => 0 above, this will never happen, but
                    #    to prepare => 1 in $defunct_only mode would be too slow
                    my $prob = $ds_error ? 'a bad datasource' : 'no dataelements';
                    $object .= $backend->xml_tag('attribute', "This has $prob; investigate with [vrpipe-status --setup $ps_id] and consider deleting it with [vrpipe-setup --setup $ps_id --delete]", qq[name="problems"]);
                }
                else {
                    $object .= $backend->xml_tag('attribute', "There is a problem with the DataSource for this pipeline, so no more information can be retrieved about it.\n$ds_error\n", qq[name="problems"]);
                }
                push(@objects, $object);
                next;
            }
            
            my $num_incomplete = $incomplete_pager->total_entries;
            next if $incomplete_only && !$num_incomplete;
            
            if ($defunct_only) {
                if ($num_incomplete && $setup->active == 0) {
                    $object .= $backend->xml_tag('attribute', "This is inactive but has $num_incomplete incomplete dataelements; if this setup was started but then abandoned (due to an error setting it up, or it being replaced by another setup) consider deleting it with [vrpipe-setup --setup $ps_id --delete]", qq[name="problems"]);
                    push(@objects, $object);
                }
                next;
            }
            
            my $pipeline     = $setup->pipeline;
            my $step_members = $pipeline->step_members;
            unless ($brief) {
                # pipeline details
                $object .= '<attribute name="pipeline"><object class="Pipeline" display_mode="full">';
                foreach my $attr (qw(id name description)) {
                    $object .= $backend->xml_tag('attribute', $pipeline->$attr(), qq[name="$attr"]);
                }
                $object .= $backend->xml_tag('attribute', $step_members, q[name="num_steps"]);
                $object .= '</object></attribute>';
                
                # setup options and output root
                my $ps_opts = $setup->options;
                $object .= '<attribute name="options">';
                if (keys %$ps_opts) {
                    $object .= $backend->hash_to_xml($ps_opts);
                }
                else {
                    $object .= '(used with default/no options)';
                }
                $object .= '</attribute>';
                $object .= $backend->xml_tag('attribute', $setup->output_root->stringify, q[name="output_root"]);
                
                # datasource details
                $object .= '<attribute name="datasource"><object class="DataSource" display_mode="full">';
                foreach my $attr (qw(id type method source)) {
                    $object .= $backend->xml_tag('attribute', $datasource->$attr(), qq[name="$attr"]);
                }
                my $ds_opts = $datasource->options;
                $object .= '<attribute name="options">';
                if (keys %$ds_opts) {
                    $object .= $backend->hash_to_xml($ds_opts);
                }
                else {
                    $object .= '(used with default/no options)';
                }
                $object .= '</attribute>';
                $object .= '</object></attribute>';
            }
            
            $object .= $backend->xml_tag('attribute', $num_elements,   q[name="elements_total"]);
            $object .= $backend->xml_tag('attribute', $num_incomplete, q[name="elements_incomplete"]);
            if ($num_incomplete) {
                my %status_hash;
                my $fully_complete = $num_elements - $num_incomplete;
                $status_hash{$step_members} = $fully_complete;
                my $num_steps_complete = $fully_complete * $step_members;
                while (my $incompletes = $incomplete_pager->next) {
                    foreach my $es (@$incompletes) {
                        my $completed_steps = $es->completed_steps;
                        $num_steps_complete += $completed_steps;
                        $status_hash{$completed_steps}++;
                    }
                }
                $object .= '<attribute name="steps_completed">' . $backend->hash_to_xml(\%status_hash, [sort { my ($ay) = $a =~ /^(\d+)/; my ($be) = $b =~ /^(\d+)/; $ay <=> $be } keys %status_hash]) . '</attribute>';
                
                my $steps_to_complete = $num_elements * $step_members;
                my $percent_complete = sprintf("%0.2f", (100 / $steps_to_complete) * $num_steps_complete);
                $object .= $backend->xml_tag('attribute', "$percent_complete\%", qq[name="completion" explanation="Pipeline currently $percent_complete\% complete ($num_steps_complete / $steps_to_complete steps completed)"]);
                
                my $farm = $setup->controlling_farm;
                if ($farm) {
                    my ($farm_server) = VRPipe::FarmServer->search({ farm => $farm });
                    if (!$farm_server || !$farm_server->alive) {
                        $object .= $backend->xml_tag('attribute', "WARNING! setup may be stalled because it is being controlled by the VRPipe server for farm $farm, but no server for that farm is currently alive", q[name="problems"]);
                    }
                }
                
                my $pager = VRPipe::Submission->search_paged({ "_done" => 0, 'stepstate.pipelinesetup' => $setup->id }, { join => ['stepstate'], prefetch => 'job' });
                my %sub_stats;
                while (my $subs = $pager->next(no_resetting => 1)) {
                    foreach my $sub (@$subs) {
                        next if $sub->done;
                        my $sub_state = $sub->failed ? 'failed' : 'scheduled';
                        if ($sub_state eq 'scheduled') {
                            my $job = $sub->job;
                            $sub_state = $job->end_time ? 'processing' : ($job->heartbeat ? 'running' : 'pending');
                        }
                        $sub_stats{$sub_state}++;
                    }
                }
                if (keys %sub_stats) {
                    $object .= '<attribute name="submission_state">' . $backend->hash_to_xml(\%sub_stats, [qw(running processing pending failed)]) . '</attribute>';
                    if (keys %sub_stats == 1 && exists $sub_stats{failed}) {
                        my $failed = $sub_stats{failed};
                        if ($failed >= $num_incomplete) {
                            $object .= $backend->xml_tag('attribute', "WARNING! It looks like this setup may be STALLED due to repeated failures.\nInvestigate using: vrpipe-submissions --setup " . $setup->id . " --failed", q[name="problems"]);
                        }
                    }
                }
                #*** else { well, what is happening to this setup then? }
            }
            else {
                if ($num_elements == 0) {
                    $object .= '<attribute name="completion" explanation="Pipeline has no inputs to work on (yet?), so has done nothing.">n/a</attribute>';
                }
                else {
                    $object .= '<attribute name="completion" explanation="Pipeline currently 100% complete!">100%</attribute>';
                }
            }
            
            push(@objects, $object);
        }
        
        if (@objects) {
            my $mode = $list ? 'list' : ($brief ? 'brief' : ($defunct_only ? 'defunct' : 'full'));
            $xml .= '<objects>' . join('', map { qq[<object class="PipelineSetup" display_mode="$mode">] . $_ . '</object>' } @objects) . '</objects>';
        }
    }
    
    return $xml;
}

sub local_scheduler {
    my ($req, $ls_watcher) = @_;
    
    my $opts = $backend->req_to_opts($req);
    my $mode = $opts->{mode} || die "a mode is required\n";
    my $ids  = $opts->{id};
    my @ids;
    if ($ids) {
        if (ref($ids)) {
            @ids = @$ids;
        }
        else {
            @ids = ($ids);
        }
    }
    
    my $xml = '';
    if ($mode eq 'start') {
        $xml = '<title>Local Scheduler</title>';
        $ls_watcher->start;
        $xml .= '<response_line>Local Scheduler started</response_line>';
    }
    elsif ($mode eq 'stop') {
        $xml = '<title>Local Scheduler</title>';
        $ls_watcher->stop;
        $xml .= '<response_line>Local Scheduler stopped</response_line>';
    }
    elsif ($mode eq 'submit') {
        $xml = '<title>Job Submission to Local Scheduler</title>';
        my $cmd = $opts->{cmd} || die "a cmd is required when submitting\n";
        my $o   = $opts->{out} || die "the out option is required when submitting\n";
        my $e   = $opts->{err} || die "the err option is required when submitting\n";
        my $a   = $opts->{a};
        my $env = $opts->{env} || {};
        my $ls = VRPipe::LocalScheduler->new(o => $o, e => $e, $a ? (a => $a) : ());
        $xml .= $backend->xml_tag('response_line', $ls->submit($cmd, $env));
    }
    elsif ($mode eq 'jobs') {
        $xml = '<title>Jobs in the Local Scheduler</title>';
    }
    elsif ($mode eq 'kill') {
        $xml = '<title>Jobs killed from the Local Scheduler</title>';
        @ids || die "at least 1 id must be supplied\n";
    }
    else {
        die "unknown mode '$mode'\n";
    }
    
    if ($mode eq 'jobs' || $mode eq 'kill') {
        my $ls = VRPipe::LocalScheduler->new;
        my ($lines, $warnings) = $ls->$mode(\@ids);
        foreach my $line (@$warnings) {
            $xml .= $backend->xml_tag('warning', $line);
        }
        foreach my $line (@$lines) {
            $xml .= $backend->xml_tag('response_line', $line);
        }
    }
    
    return $xml;
}

sub continuation_test {
    my $request = shift;
    $request->print("Your name: <form><input type=text name=name></form>");
    $request->next; # this waits for the form to be submitted!
    my $name = $request->param('name');
    $request->print("Hello $name!");
}
