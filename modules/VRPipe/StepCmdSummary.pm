
=head1 NAME

VRPipe::StepCmdSummary - summarise what a Step does

=head1 SYNOPSIS

*** more documentation to come

=head1 DESCRIPTION

Most L<VRPipe::Step>s define some command line that must be executed. Users
have the ability to investigate how a particular B<VRPipe> output file was
generated by listing all these command lines from all the Steps involved in
making it. However there is typically a lot of less than useful information in
literal command lines, and things can become far too verbose especially when
they may also be looking at how lots of their output files were generated.

The goal of a StepCmdSummary is to present the user with a simplified summary
of what the Step did, showing them all the important information that might be
needed to generically repeat what was done (perhaps outside of B<VRPipe>, on
different files, in a different directory structure). It stores 3 critical
things: the executable used, its version, and a summary line of text that
includes user options but excludes things like input and output file paths.

A StepCmdSummary should be created within the C<body_sub()> of any non-trivial
Step, especially those that take user options that result in a different
"answer" being generated.

For example, consider a Pipeline whose goal is to take an input file and run
B<foo> on it, but it was written to improve speed by doing things in parallel
by first splitting the input into chunks (Step 1), run B<foo> on each chunk
(Step 2) and merge the results back together (Step 3). Step 1 might take a user
option on how big the chunks should be, but because Steps 1 and 3 are both
ultimately artifacts of the Pipeline that simply make it run faster without
changing the final result, those Steps would not create StepCmdSummarys.

Considering Step 2 in the example, let's say it was written so that instead of
directly calling B<foo> on the command line, the call to B<foo> is instead
wrapped in some B<Perl> code which carefully checks the output of B<foo> to
make sure it is valid and not truncated. The literal command line here is a
call to Perl, but this again is an artifact of the Pipeline. Step 2 should have
a StepCmdSummary something like "C<foo --user_opt_1 --user_opt_2 $input_file >
$output_file>". In this wat it is clear what work was "really" being done (we
ran B<foo>), it is clear what user options to B<foo> were used, and meaningless
things like file paths are replaced with literal $ placeholders.

*** more documentation to come

=head1 AUTHOR

Sendu Bala <sb10@sanger.ac.uk>.

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2011 Genome Research Limited.

This file is part of VRPipe.

VRPipe is free software: you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program. If not, see L<http://www.gnu.org/licenses/>.

=cut

use VRPipe::Base;

class VRPipe::StepCmdSummary extends VRPipe::PersistentLocklessCreate {
    our %version_cache;
    
    has 'exe' => (
        is     => 'rw',
        isa    => Varchar [255],
        traits => ['VRPipe::Persistent::Attributes'],
        is_key => 1
    );
    
    has 'version' => (
        is     => 'rw',
        isa    => Varchar [64],
        traits => ['VRPipe::Persistent::Attributes'],
        is_key => 1
    );
    
    has 'summary' => (
        is     => 'rw',
        isa    => Text,
        traits => ['VRPipe::Persistent::Attributes'],
        is_key => 1
    );
    
    __PACKAGE__->make_persistent();
    
    method determine_version (ClassName|Object $self: Str $cmd, Str $regex) {
        if (defined $version_cache{$cmd}) {
            return $version_cache{$cmd};
        }
        
        open(my $fh, "$cmd 2>&1 |") || $self->throw("Could not start $cmd");
        my $version = 0;
        
        while (<$fh>) {
            if (/$regex/) {
                $version = $1;
                last;
            }
        }
        close($fh);
        
        $version_cache{$cmd} = $version;
        
        return $version;
    }
}

1;
